#pragma once

#include <global_string.h>
#include "InconsistencyCoverage.h"
#include "simulation.h"
#include <io/xml.h>


/*
The IC profile generated by the statistics unit can be either the destination (we create it)
or a source for the comparator
*/
//#define IC_PROFILE_IS_MERGE_COMPARATOR_SOURCE



namespace Statistics
{
	void	Include(const IC::TSample& textureInconsistency, count_t inconsistentEntities, count_t totalEntities);

	float	GetMean(const IC::TSample& textureInconsistency);
	
	void	ExportToFile(const PathString&);
	void	ImportMean(const PathString&);

	TExperiment	SignalRecoveryFailed(const Simulation&sim);
	TExperiment	SignalSimulationEnd(const Simulation&sim);

	TExperiment	Begin();

	bool		HasCurrentExperiment();
	TExperiment	GetCurrentExperiment();
	double		GetEntityDensityPerRCube();
	double		GetEntityDensityPerRCube(const TExperiment&);
	#ifndef NO_SENSORY
		double	GetEntityVisitionDensity();
		double	GetEntityVisitionDensity(const TExperiment&);
	#endif
	count_t		GetECStep(const TExperiment&ex);

	template <typename T>
	struct TSDSample
	{
		T		sum = 0,
				squareSum = 0;
		count_t numSamples = 0;


		/**/	TSDSample()	{}
		/**/	TSDSample(T sum, count_t numSamples =1):sum(sum),squareSum(sum*sum), numSamples(numSamples)
		{}
		/**/	TSDSample(T sum, T squareSum, count_t numSamples):sum(sum),squareSum(squareSum), numSamples(numSamples)
		{}

		void	operator+=(const TSDSample<T>&other)
		{
			sum += other.sum;
			squareSum += other.squareSum;
			numSamples += other.numSamples;
		}
		void	operator+=(T v)
		{
			sum += v;
			squareSum += v*v;
			numSamples ++;
		}
		TSDSample<T> operator*(T fc) const
		{
			return TSDSample<T>(sum*fc,squareSum*fc*fc,numSamples);
		}
		TSDSample<T> operator/(T fc) const
		{
			return TSDSample<T>(sum/fc,squareSum/fc/fc,numSamples);
		}
		TSDSample<T> operator+(const TSDSample<T>&other) const
		{
			return TSDSample<T>(sum + other.sum,squareSum + other.squareSum, numSamples + other.numSamples);
		}

		void	ToXML(XML::Node&outNode) const
		{
			double mean = (double)sum/double(numSamples);
			double sqrMean = (double)squareSum/double(numSamples);
			double deviation = sqrt(sqrMean - M::Sqr(mean));

			outNode.Set("mean",mean);
			outNode.Set("deviation",deviation);
			outNode.Set("sum",sum);
			outNode.Set("squareSum",squareSum);
			outNode.Set("numSamples",numSamples);
		}

		void	ToXML(XML::Node&outNode, const TSDSample<T>&min, const TSDSample<T>&max) const
		{
			double mean = (double)sum/double(numSamples);
			double sqrMean = (double)squareSum/double(numSamples);
			double deviation = sqrt(sqrMean - M::Sqr(mean));

			const float mn = min.Get();
			const float mx = max.Get();
			ASSERT_LESS_OR_EQUAL__(mn,mx);
			const float rel = mean - mn;
			const float rng = (mx - mn);
			outNode.Set("relative",rel/rng);
			outNode.Set("mean",mean);
			outNode.Set("deviation",deviation);
			outNode.Set("sum",sum);
			outNode.Set("squareSum",squareSum);
			outNode.Set("numSamples",numSamples);
		}



		void	Import(const XML::Node*node)
		{
			if (!node)
				return;
			Import(*node,"sum",sum);
			Import(*node,"squareSum",squareSum);
			Import(*node,"numSamples",numSamples);
		}

		template <typename T1>
		static void	Import(const XML::Node&node, const char*key,T1&value)
		{
			StringRef sval;
			ASSERT1__(node.Query(key,sval),key);
			ASSERT1__(convert(sval.pointer(),sval.GetLength(),value),sval);
		}


		double	Get() const
		{
			return numSamples ? (double)sum / numSamples : 0;
		}

		double GetPlusOne() const
		{
			return (double)(sum+1) / (numSamples+1);
		}
	};


	struct TStateDifference
	{
		CONSTRUCT_ENUMERATION15(Metric,
			C_SpatialDelta,			//Spatial difference between consistent entity and local entity (sometimes available)
			I_SpatialDelta,			//Spatial difference between local entity and consistent entity (always available)
			I_Omega,			
			ICSize,					//Number of inconsistent IC cells (/64 to get percentage)
			C_EntitiesInMergedIC,	//Consistent entities in remaining IC
			C_EntitiesInMerged,		//Consistent entities in consistent merged SDS
			I_EntitiesInMergedIC,
			C_MissingEntitiesInMergedIC,	//Entities that should be there according to consistent state, but were not found in local state
			I_UnwantedEntitiesInMergedIC,	//Entities in the local state, that are not supposed to be here according to the consistent state
			C_InconsistencyProbability,	//[0,1] probability that inconsistent entities lie outside the remaining inconsistent area. apparently never correctly captured
			C_MissingProbability,		//[0,1] probability that entity should be there according to consistent state, but was not found in local state
			I_UnwantedProbability,		//[0,1] probability that entity is in local state, but should not according to the consistent state
			C_ICIsFullyConsistentInMergedIC,		//[0,1] probability that no entity in the IC is inconsistent
			C_ICIsCompletelyInconsistentInMergedIC,		//[0,1] probability that all entities in the IC are inconsistent
			C_ICIsEmpty
		);


		static String GetOldName(Metric m)
		{
			switch (m)
			{
				case Metric::C_SpatialDelta:
					return "inconsistency";
				case Metric::C_EntitiesInMerged:
					return "entitiesInSDS";
				case Metric::C_EntitiesInMergedIC:
					return "entitiesInInconsistentArea";
				case Metric::C_MissingEntitiesInMergedIC:
					return "missingEntities";
				case Metric::I_Omega:
					return "omega";
				case Metric::ICSize:
					return "icSize";
				case Metric::I_UnwantedEntitiesInMergedIC:
					return "overAccountedEntities";
			}
			return "";
		}

		FixedArray<TSDSample<double>,Metric::N>	value;

		/**/				TStateDifference()	{};
		static TStateDifference Minimum(const TStateDifference&a, const TStateDifference&b)
		{
			TStateDifference rs;
			using std::min;
			for (index_t i = 0; i < Metric::N; i++)
				rs.value[i] = a.value[i].Get() >= b.value[i].Get() ? b.value[i] : a.value[i];
				//rs.value[i] = min(a.value[i].Get(),b.value[i].Get());
			return rs;
		}
		static TStateDifference Maximum(const TStateDifference&a, const TStateDifference&b)
		{
			TStateDifference rs;
			using std::max;
			for (index_t i = 0; i < Metric::N; i++)
				rs.value[i] = a.value[i].Get() < b.value[i].Get() ? b.value[i] : a.value[i];
				//rs.value[i] = max(a.value[i].Get(),b.value[i].Get());
			return rs;
		}
		static double Avg(double a, double b)
		{
			return (a+b)*0.5;
		}

		void				operator+=(const TStateDifference&other)
		{
			for (index_t i = 0; i < Metric::N; i++)
				value[i] += other.value[i];
		}

		void				AddMean(const TStateDifference&other)
		{
			for (index_t i = 0; i < Metric::N; i++)
				value[i] += other.value[i].Get();
		}

		TStateDifference	operator+(const TStateDifference&other) const
		{
			TStateDifference rs;
			for (index_t i = 0; i < Metric::N; i++)
				rs.value[i] = value[i] + other.value[i];
			return rs;
		}

		void	ToXML(XML::Node&outNode) const
		{
			for (index_t i = 0; i < Metric::N; i++)
				value[i].ToXML(outNode.Create(Metric::Reinterpret(i).ToString()));
		}

		void	ToXML(XML::Node&outNode, const TStateDifference&min, const TStateDifference&max) const
		{
			for (index_t i = 0; i < Metric::N; i++)
				value[i].ToXML(outNode.Create(Metric::Reinterpret(i).ToString()),min.value[i],max.value[i]);
		}

		void	Import(const XML::Node*node)
		{
			if (!node)
				return;
			for (index_t i = 0; i < Metric::N; i++)
			{
				auto imp = node->Find(Metric::Reinterpret(i).ToString());
				if (!imp)
					imp = node->Find(GetOldName(Metric::Reinterpret(i)));
				value[i].Import(imp);
			}
		}

	};

	enum class MergeStrategy
	{
		EntitySelective,
		Exclusive,
		ExclusiveWithPositionCorrection,

		Count
	};

	CONSTRUCT_ENUMERATION4(ConfidenceThreshold,
		Zero,
		Half,
		HalfPlusWI,
		One
	);


	enum class ICReductionFlags
	{
		RegardEntityState = 0x1,
		RegardEntityEnvironment = 0x2,	//requires RegardEntityState

		#ifdef EXTENDED_IC_GRID
			//exclusive (zero or one of these may be set):
			RegardOriginBitField = 0x4,
			RegardOriginRange = 0x8,
			RegardFuzzyOriginRange = 0x10,

			NumBits = 5,
		#else
			NumBits = 2,
		#endif

		NumCombinations = 1 << NumBits
	};


	inline constexpr ICReductionFlags operator|(ICReductionFlags a, ICReductionFlags b)
	{
		typedef std::underlying_type<ICReductionFlags>::type U;
		return ICReductionFlags( U(a) | U(b) );
	}
	inline constexpr bool operator&(ICReductionFlags a, ICReductionFlags b)
	{
		typedef std::underlying_type<ICReductionFlags>::type U;
		return ( U(a) & U(b) ) != 0;
	}


	struct TICReductionConfig
	{
		ICReductionFlags	flags;
		count_t				overlapTolerance=0,	//number of generations that are allowed to overlap between two IC ranges. Effective only if RegardRange or RegardFuzzyRange are set
							minEntityPresence=0;
		IC::content_t		maxDepth=0xFF,minSpatialDistance=0;

		bool				operator==(const TICReductionConfig&other) const
		{
			return CompareTo(other) == 0;
		}
		bool				operator!=(const TICReductionConfig&other) const {return !operator==(other);}

		friend hash_t		Hash(const TICReductionConfig&self)
		{
			return HashValue() << std::underlying_type<ICReductionFlags>::type(self.flags) << self.overlapTolerance << self.minEntityPresence << self.maxDepth << self.minSpatialDistance;
		}

		int					CompareTo(const TICReductionConfig&other) const
		{
			OrthographicComparison comp;
			comp.AddComparison(flags,other.flags);
			comp.AddComparison(overlapTolerance,other.overlapTolerance);
			comp.AddComparison(minEntityPresence,other.minEntityPresence);
			comp.AddComparison(maxDepth,other.maxDepth);
			comp.AddComparison(minSpatialDistance,other.minSpatialDistance);
			return comp;
		}

		bool				operator<(const TICReductionConfig&other) const
		{
			return CompareTo(other) < 0;
		}
		bool				operator>(const TICReductionConfig&other) const
		{
			return CompareTo(other) > 0;
		}

		bool				IsPossible() const;
	};


	struct TProbabilisticICReduction
	{
		TICReductionConfig	config;
		TSDSample<UINT64>	totalGuesses,
							consideredConsistent,
							correctGuesses,
							actuallyConsistent,
							shouldHaveConsideredConsistent,
							shouldNotHaveConsideredConsistent;

		void				Add(const TProbabilisticICReduction&);
		void				Import(const XML::Node*n);
		void				ToXML(XML::Node&n) const;

		bool				operator<(const TProbabilisticICReduction&other) const {return config < other.config;}
		bool				operator>(const TProbabilisticICReduction&other) const {return config > other.config;}


		double				GetTruePositive() const
		{
			return (consideredConsistent.Get() - shouldNotHaveConsideredConsistent.Get());
		}

		double				GetFalsePositive() const
		{
			return shouldNotHaveConsideredConsistent.Get();
		}
		double				GetFalseNegative() const
		{
			return shouldHaveConsideredConsistent.Get();
		}

		double				GetTrueNegative() const
		{
			return ( (totalGuesses.Get() - consideredConsistent.Get()) - shouldHaveConsideredConsistent.Get());
		}

		float2				GetSensitivitySpecificality() const
		{
			const double truePositive = GetTruePositive();
			const double falseNegative = GetFalseNegative();
			const double trueNegative = GetTrueNegative();
			const double falsePositive = GetFalsePositive();
			return float2(
				truePositive / (truePositive + falseNegative),
				trueNegative / (trueNegative + falsePositive)
			);
		}
	};

	#ifdef IC_PROFILE_IS_MERGE_COMPARATOR_SOURCE
	class ProfileComparator : public IC::Comparator
	{
		float	GetBadness(const IC::TSample&s) const;
	public:
		virtual int operator()(const IC::TSample&s0, const IC::TSample&s1) const override
		{
			return Compare(GetBadness(s0),GetBadness(s1));
		}
		virtual String GetName() const override {return "Profile";}
	};
	#endif


	void	CaptureInconsistency(const IC&, const EntityStorage&inconsistent, const EntityStorage&consistent, const TGridCoords&shardOffset);
	void	CaptureICTest(const TProbabilisticICReduction&);
	void	CapturePreMerge(const TStateDifference&preMergeA, const TStateDifference&preMergeB, const TStateDifference&general);
	void	CaptureMergeResult(const TMergeConfig&,const TStateDifference&postMerge);
	void	ExportMergeResults(const TExperiment&);
	void	ImportMergeResults(const TExperiment&);
	void	ExportMergeResults();
}


struct TBaseMergeConfig
{
	Statistics::MergeStrategy	strategy;
	Statistics::ConfidenceThreshold confidenceThreshold;
};

struct TMergeConfig : public TBaseMergeConfig
{
	const IC::Comparator		*icComp = nullptr;		//!< Must not be null
	const IC::BadnessEstimator	*icBadness = nullptr;	//!< If not null, overrides icComp during exclusive selection

	/**/						TMergeConfig(){}
	/**/						TMergeConfig(const TBaseMergeConfig&cfg) :  TBaseMergeConfig(cfg) {}
};

