#ifndef eve_fractalH
#define eve_fractalH

template <class Map>    class EveFractalMap;


/******************************************************************************************

Language-dependent fractal-visualizer. Experimental.

This file is part of the DeltaWorks-Foundation or an immediate derivative core application.
Original Author: Stefan Elsen
Copyright (C) 2006 University of Trier, Computer Science Department, Germany.

A royalty-free, non-exclusive, perpetual right to read, modify, compile,
and/or use this file in any way suited is hereby granted to all students and associates
of the Computer Science Department of the University of Trier.
This right may be granted to other individuals or parties in any modified form as well
as denied to any member of the above mentioned group by the Authorities of the
Computer Science Department of the University of Trier.

The right granted in the above section is expressly made subject to and limited by the
following conditions and restrictions:
a) Any modifications to this file must be made available to the Computer Science Department
of the University of Trier.
b) Disclosure of this file, modified or unmodified, in parts or in its entirety to third
parties is strictly prohibited.

All rights and privileges that have not explicitly been granted are reserved.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

******************************************************************************************/


#include "eve.core.h"
#include "eve.aspect.h"
#include "eve.3dlanguage.h"
#include "eve.timing.h"
#include "eve.scenery.h"

#ifndef BEGIN
    #define BEGIN   SCENERY_LOG("entering");
#endif
#ifndef END
    #define END     SCENERY_LOG("exiting");
#endif

#ifndef LBEGIN
    #define LBEGIN  SCENERY_LOG("entering(l)");
#endif

#include <structure/fractal_map.h>




#define EVE_NATIVE_LAYERS        4          //layers on which objects (such as trees) are rendered.


#define EVE_FRACTAL_DETAIL_RANGE            6   //maximum-distance of highest rendered detail to lowest rendered
#define EVE_VELOCITY_BLUR                   0.35 //blur-factor on high velocities (the higher the blurrier)
#define EVE_MAX_VELOCITY_CHANGE_PER_SECOND  0.001 //this is a factor (not a delta)


//#define EVE_VERTEX_UPLOAD_TEST

/*
#include <gl/gl.h>
#include <gl/gl_generators.h>
#include <gl/gl_enhancement.h>*/
#include <math/matrix.h>





//extern GLuint   debug_cylinder, debug_sphere;


enum eGroundType   {GT_NORMAL,GT_SNOWY};

extern bool ati_bug;

namespace EveStatistics
{
        extern  unsigned    vram,ram,memory,sectors,rendered;
};

EVE_FRAGMENT EveMapObject
{
        CVStructure<CVStdDef>   structure;
        float                   ideal_fertility,fertility_tolerance,ideal_height,height_tolerance,general_probability,p,
                                center[3],radius;
        CAbstractHull<float>    collision_object;
        unsigned                allocated,prev_allocated,limit;
        
        CVector<CVStructureInstance<CVStdDef> >         instance_field;
        CReferenceVector<EveStructureEntity<CVStdDef> > entity_field;
};

EVE_FRAGMENT EveFractalNativeLayer;

EVE_FRAGMENT EveMapObjectReference
{
        float                   system[16];
        EveMapObject           *origin;
        CAbstractHull<float>    collision_object;
        EveFractalNativeLayer  *layer;
};

EVE_FRAGMENT EveFractalNativeLayer
{
        CVector<EveMapObjectReference>  native_objects;
};

class EveColorMap
{
public:
template <class Map, class Vertex, class Float, class Float2>
        static Float  apply(const Map&map, const Vertex&vertex, const Float vertical[3],    Float2 coord[2])
        {
            Float   lower = vmax(map.water_height,map.bottom.height),
                    relative_height = (vertex.data.height-map.water_height)/(map.top.height-map.bottom.height),
                    up_intensity = vpow(_dot(vertical,vertex.normal),6),
                    average_temperature = clamped((1.0f-relative_height)*up_intensity,0,1),
                    fertility = vertex.data.fertility*average_temperature,
                    tree_fertility = (vpow(vertex.data.appearance,0.4))*linearStep(fertility,0.1,0.7)*clamped((vertex.data.height-map.water_height)/(map.top.height-map.water_height)*60.0,0,1);
            coord[0] = clamped(fertility,0,1);
            coord[1] = clamped(relative_height>0?(1.0-average_temperature)*0.75+0.25:0.25+relative_height,0,1);   //water-barrier at 0.25
            return tree_fertility;
        }
};


template <unsigned MapExponent=5> class   EveDefaultFractalConfig
{
public:
        typedef EveColorMap         Map;
        static const unsigned       Exponent=MapExponent,
                                    AdditionalTextures=0;
//        typedef CDefaultGenerator   Generator;
        typedef CVerticalNorm       Norm;
};


class EveFractalMapView
{
protected:
        EveCamera<float>        camera;
        float                   velocity,
                                movement_direction[3];
        unsigned                most_detail;
        float                   user_location[3],cast_matrix[16],visual_normal[4][3],
                                texture_x[3],texture_y[3],texture_up[3],texture_root[3];
        
public:
        float                   system[16],visual_range,detail_limit,lod,
                                invert[16];

        unsigned                visible_sectors;
        
        EveVisualVolume<float>  visual_volume;

                                EveFractalMapView();

        void                    begin();

        void                    setSystem(const float sys[16]);
        void                    setCamera(const EveCamera<float>&camera);
        void                    updateInvert();
        const float*            origin()        const;
        const float*            getSystem()     const;
        void                    resolveESX(float target[3]) const;    //eye-space x-texture-alignment
        void                    resolveESY(float target[3]) const;    //eye-space y-texture-alignment

    template <class Module, class Norm>
        eCastResult             cast(CFractalSector<Module,Norm>*face);

};




template <class GL, unsigned Exponent> class EveFractalMapPatterns
{
private:
        typedef typename GL::IndexType      IndexType;
        typedef typename GL::IndexObject    IndexObject;
        typedef CFractalIndexMap<Exponent>  IndexMap;
        
        static  IndexMap                map;
        static  const unsigned          range = (1<<Exponent)+1;
        static  bool                    created,uploaded;
        static  typename GL::IndexType  core_pattern[(range-4)*(range-4)*3],
                                        *current,*ocurrent;
                                
        static void             createCorePattern();
        static void             makePattern(unsigned r0, unsigned r1, unsigned r2);
public:
        static  const unsigned  pattern_exponent = Exponent;
        static  IndexObject     pattern_buffer;
        static  IndexType       pattern[Exponent*Exponent*Exponent*range*range*3],
                                pattern_offset[Exponent*Exponent*Exponent+1];
 
                                
        static void             create();           //creates all patterns but does not upload
        static void             makePatterns();     //uploads pattern (also creates if necessary)
};





template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveFractalModule
{
private:
        static void                         createCorePattern();
        static void                         makePattern(unsigned r0, unsigned r1, unsigned r2);

public:
        typedef EveFractalModule<GL,ConfigModule>    Reflection;
        typedef ConfigModule                Config;


//        typedef typename GL::FloatType      Float;
        typedef double                      Float;
        typedef typename GL::IndexType      Index;
        typedef typename GL::VertexObject   VObj;
        typedef typename GL::IndexObject    IObj;
        typedef typename GL::TextureObject  TObj;
        typedef typename GL::QueryObject    QObj;

        typedef typename Config::Map        ColorMap;
//        typedef typename Config::Generator  Generator;
        static const unsigned               Exponent = Config::Exponent,
                                            AdditionalTextures = Config::AdditionalTextures;

        typedef CFractalInterpolator    Interpolator;

        class Sector:public EveFractalNativeLayer
        {
        public:
                typedef Float           FloatType;          //general float-type used for
                typedef CFractalIndexMap<Exponent>  IndexMap;
                static const unsigned   Size=Exponent;
                static const unsigned   vertices    = NUM_VERTICES(Size);
                static const unsigned   range       = (1<<Size)+1;

                static  IndexMap        map;

                typename GL::FloatType  surface_map[vertices*10],water_map[vertices*6],tree_map[vertices*7];
                bool                    underwater[vertices];

                VObj                    surface_buffer,water_buffer,tree_buffer;
                bool                    water_visible,trees_visible,objects_defined,reload;

                                        Sector();
        virtual                        ~Sector();
        template <class Super, class Norm>
                static void             update(Super&super,CFractalSector<Reflection,Norm>*face);
        template <class Super, class Norm>
                static void             updateNormals(Super&super,CFractalSector<Reflection,Norm>*face);
                bool                    defineSphere(CAbstractSphere<Float>&sphere);
                void                    upload();
        };
        
        
        class Map:public EveFractalMapView, public EveFractalMapPatterns<GL,Exponent>
        {
        public:
                typedef GL              EveGL;

                static const unsigned   range = (1<<Exponent)+1;
                static const unsigned   MaxLevel = 32,
                                        MaxSectors = 0x100;
                static const unsigned   TextureLayers = Config::AdditionalTextures;
                float                   water_height,tree_height;
                eStructureStatus        default_status;
                CVector<EveMapObject>   native_objects[EVE_NATIVE_LAYERS];
                
                                        Map():default_status(STAT_STATIC)   {}

                
                EveMapObjectReference*  getObject(unsigned depth, const Float&fertility, const Float&height, float random);

        };
        


        static  EveScenery<CVStdDef,GL> scenery;
};




template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveFractalCloudModule
{
public:
        typedef EveFractalCloudModule<GL,ConfigModule>    Reflection;
        typedef ConfigModule                Config;


        //typedef typename GL::FloatType      Float;
        typedef double                      Float;
        typedef typename GL::IndexType      Index;
        typedef typename GL::VertexObject   VObj;
        typedef typename GL::IndexObject    IObj;
        typedef typename GL::TextureObject  TObj;
        typedef typename GL::QueryObject    QObj;

        typedef typename Config::Map        ColorMap;
        static const unsigned               Exponent = Config::Exponent,
                                            vertices = NUM_VERTICES(Exponent),
                                            range       = (1<<Exponent)+1;

        class Interpolator
        {
        public:
        template <class Module, class Norm>
            inline static void      interpolate(const CFractalPoint<typename Module::Sector::FloatType>&p0,
                                            const CFractalPoint<typename Module::Sector::FloatType>&p1,
                                            CFractalPoint<typename Module::Sector::FloatType>&result,
                                            unsigned index, const TFractalInterpolatorContext<Module,Norm>&context);
        };

        class Sector
        {
        public:
                typedef Float           FloatType;          //general float-type used for
                static const unsigned   Size=Exponent;
                static const unsigned   vertices    = NUM_VERTICES(Size);
                typedef CFractalIndexMap<Exponent>  IndexMap;

                static  IndexMap        map;

                Float                   ceiling_map[vertices*7],floor_map[vertices*7];
                VObj                    ceiling_buffer,floor_buffer;
                bool                    visible,reload;

                                        Sector();
        virtual                        ~Sector();
        template <class Super, class Norm>
                static void             update(Super&super,CFractalSector<Reflection,Norm>*face);
        template <class Super, class Norm>
                static void             updateNormals(Super&super,CFractalSector<Reflection,Norm>*face);
                bool                    defineSphere(CAbstractSphere<Float>&sphere);
                void                    upload();
        };


        class Map:public EveFractalMapView, public EveFractalMapPatterns<GL,Exponent>
        {
        public:
                typedef GL              EveGL;

                static const unsigned   range = (1<<Exponent)+1;
                static const unsigned   MaxLevel = 32,
                                        MaxSectors = 0x100;
                                        
                float                   cloud_height,cloud_blur;


        };
};








//#include "eve.fractal_core.h"

template <class GL, class Config>   class   EveSphereMap;
template <class GL, class Config>   class   EvePlanarMap;
template <class GL, class Config>   class   EveExtendableMap;

template <class GL, class Config>   class   EveCloudSphere;
template <class GL, class Config>   class   EvePlanarClouds;
template <class GL, class Config>   class   EveExtendableClouds;





template <class Map> class EveFractalMap:public Map
{
public:
        typedef typename Map::Float Float;
private:
        float                   fine_ground_system[16],large_ground_system[16],fine_water_system_a[16],fine_water_system_b[16],large_water_system_a[16],large_water_system_b[16];
static  typename Map::EveGL::TextureObject  transparency[4];

public:
    #ifdef __GNUC__
        using   Map::system;
        using   Map::detail_limit;
        using   Map::most_detail;
        using   Map::top_level;
        using   Map::trace;
        using   Map::user_location;
        using   Map::texture_up;
        using   Map::texture_root;
        using   Map::texture_x;
        using   Map::texture_y;
        using   Map::pattern;
        using   Map::pattern_buffer;
        using   Map::sector_buffer;
        using   Map::sector_count;

    #endif
        typedef typename Map::EveGL::TextureObject  Texture;
    
        float                   visual_object_range,
                                fine_ground_scale,large_ground_scale,fine_water_scale,large_water_scale,fine_water_speed,large_water_speed;


        enum    eTextureSlot{GroundColor=0,GroundDetail=1,FineWater=0,LargeWater=1};
        Texture                 texture[3+Map::TextureLayers+1],
                                fine_water_tex,large_water_tex,
                                fine_tree_tex,large_tree_tex;
        EveMaterialConfig       ground_config,water_config,tree_config;
        
                                EveFractalMap();
                                
static  void                    initTextures();

        EveMapObject*           insertNativeObject(const CString&filename,unsigned level,float ideal_fertility, float fertility_tolerance, float ideal_height, float height_tolerance, float general_probability, unsigned instances=100);
        void                    removeFromMap(EveMapObjectReference*reference);
        void                    renderObjects();

        void                    renderLandscape();
        void                    renderTreeLayer();
        void                    renderWater();
        void                    render();
        EveMapObjectReference*  detectObjectCollision(const Float last_position[3], const Float current_position[3],Float radius, Float force_out[3]);
        bool                    intersectsVisibleMap(const Float p0[3], const Float p1[3]);
        unsigned                extractFaces(const Float box[6], typename Map::Point**field, unsigned max_triangles);
};


template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveSphereMap:public EveFractalMap<CSphereMap<EveFractalModule<GL,ConfigModule> > >
{};

template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EvePlanarMap:public EveFractalMap<CPlanarMap<EveFractalModule<GL,ConfigModule>,typename ConfigModule::Norm> >
{};

template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveExtendableMap:public EveFractalMap<CExtendableMap<EveFractalModule<GL,ConfigModule>,typename ConfigModule::Norm> >
{};





template <class Map> class EveFractalClouds:public Map
{
public:
        typedef typename Map::Float Float;

private:
static typename Map::EveGL::TextureObject   cloud_texture[4];
public:
    #ifdef __GNUC__
        using   Map::system;
        using   Map::detail_limit;
        using   Map::most_detail;
        using   Map::top_level;
        using   Map::trace;
        using   Map::user_location;
        using   Map::texture_up;
        using   Map::texture_root;
        using   Map::texture_x;
        using   Map::texture_y;
        using   Map::pattern;
        using   Map::pattern_buffer;
        using   Map::sector_buffer;
        using   Map::sector_count;
    #endif
        typedef typename Map::EveGL::TextureObject  Texture;

        EveMaterialConfig       cloud_config;


                                EveFractalClouds();
static  void                    initTextures();
        void                    render(bool floor =true, bool ceiling=true);
};


template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveCloudSphere:public EveFractalClouds<CSphereMap<EveFractalCloudModule<GL,ConfigModule> > >
{};

template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EvePlanarClouds:public EveFractalClouds<CPlanarMap<EveFractalCloudModule<GL,ConfigModule>,typename ConfigModule::Norm> >
{};

template <class GL, class ConfigModule=EveDefaultFractalConfig<> > class EveExtendableClouds:public EveFractalClouds<CExtendableMap<EveFractalCloudModule<GL,ConfigModule>,typename ConfigModule::Norm> >
{};



#include "eve.fractal.tpl.h"

#endif

