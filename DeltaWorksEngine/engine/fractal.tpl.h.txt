#ifndef eve_fractalTplH
#define eve_fractalTplH

/******************************************************************************************

Language-dependent fractal-visualizer. Experimental.

This file is part of the DeltaWorks-Foundation or an immediate derivative core application.
Original Author: Stefan Elsen
Copyright (C) 2006 University of Trier, Computer Science Department, Germany.

A royalty-free, non-exclusive, perpetual right to read, modify, compile,
and/or use this file in any way suited is hereby granted to all students and associates
of the Computer Science Department of the University of Trier.
This right may be granted to other individuals or parties in any modified form as well
as denied to any member of the above mentioned group by the Authorities of the
Computer Science Department of the University of Trier.

The right granted in the above section is expressly made subject to and limited by the
following conditions and restrictions:
a) Any modifications to this file must be made available to the Computer Science Department
of the University of Trier.
b) Disclosure of this file, modified or unmodified, in parts or in its entirety to third
parties is strictly prohibited.

All rights and privileges that have not explicitly been granted are reserved.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

******************************************************************************************/

extern unsigned upload_counter;


template <class GL, class ConfigModule> EveScenery<CVStdDef,GL>     EveFractalModule<GL,ConfigModule>::scenery;
template <class GL, class ConfigModule> typename EveFractalModule<GL,ConfigModule>::Sector::IndexMap   EveFractalModule<GL,ConfigModule>::Sector::map;
template <class GL, class ConfigModule> typename EveFractalCloudModule<GL,ConfigModule>::Sector::IndexMap   EveFractalCloudModule<GL,ConfigModule>::Sector::map;

template <class GL, unsigned Exponent>  typename GL::IndexObject    EveFractalMapPatterns<GL,Exponent>::pattern_buffer;
template <class GL, unsigned Exponent>  typename GL::IndexType      EveFractalMapPatterns<GL,Exponent>::core_pattern[(range-4)*(range-4)*3];
template <class GL, unsigned Exponent>  typename GL::IndexType      EveFractalMapPatterns<GL,Exponent>::pattern[Exponent*Exponent*Exponent*range*range*3];
template <class GL, unsigned Exponent>  typename GL::IndexType     *EveFractalMapPatterns<GL,Exponent>::current= EveFractalMapPatterns<GL,Exponent>::pattern;
template <class GL, unsigned Exponent>  typename GL::IndexType      EveFractalMapPatterns<GL,Exponent>::pattern_offset[Exponent*Exponent*Exponent+1];
template <class GL, unsigned Exponent>  typename GL::IndexType     *EveFractalMapPatterns<GL,Exponent>::ocurrent = EveFractalMapPatterns<GL,Exponent>::pattern_offset;
template <class GL, unsigned Exponent>  CFractalIndexMap<Exponent>  EveFractalMapPatterns<GL,Exponent>::map;

template <class GL, unsigned Exponent>  bool                        EveFractalMapPatterns<GL,Exponent>::created(false);
template <class GL, unsigned Exponent>  bool                        EveFractalMapPatterns<GL,Exponent>::uploaded(false);


template <class Map> typename Map::EveGL::TextureObject             EveFractalMap<Map>::transparency[4];
template <class Map> typename Map::EveGL::TextureObject             EveFractalClouds<Map>::cloud_texture[4];


template <class GL, unsigned Exponent> void EveFractalMapPatterns<GL,Exponent>::createCorePattern()
{
    BEGIN
    typename GL::IndexType*p = core_pattern;

    for (unsigned y = 3; y < range-1; y++)
    {
        for (unsigned x = 1; x < y-2; x++)
        {
            (*p++) = map.getIndex(x,y);
            (*p++) = map.getIndex(x+1,y);
            (*p++) = map.getIndex(x,y-1);
            (*p++) = map.getIndex(x+1,y);
            (*p++) = map.getIndex(x+1,y-1);
            (*p++) = map.getIndex(x,y-1);
        }
        (*p++) = map.getIndex(y-2,y);
        (*p++) = map.getIndex(y-1,y);
        (*p++) = map.getIndex(y-2,y-1);
    }

    if (p != core_pattern + ARRAYSIZE(core_pattern))
        ERROR_THROW__("bad core-pattern. local: "+IntToStr(p-core_pattern)+" global: "+IntToStr(ARRAYSIZE(core_pattern)));

    current = pattern;
    ocurrent = pattern_offset;
    END
}

template <class GL, unsigned Exponent> void EveFractalMapPatterns<GL,Exponent>::makePattern(unsigned r0, unsigned r1, unsigned r2)
{
    BEGIN
    (*ocurrent++) = current - pattern;

    unsigned r[3] = {r0,r1,r2};
    for (BYTE k = 0; k < 3; k++)
    {
        unsigned overload = range / r[k];
        unsigned*outer = map.border[k],
                *inner = map.inner_border[k];
        (*current++) = outer[0];
        (*current++) = outer[overload];
        (*current++) = inner[1];
        (*current++) = outer[overload];
        (*current++) = outer[overload*2];
        (*current++) = inner[1];

        unsigned last = overload*2;

        for (unsigned i = 1; i < range-2; i++)
        {

            if (i >= last+overload/2)
            {
                (*current++) = inner[i];
                (*current++) = outer[last];
                (*current++) = outer[last+overload];
                last += overload;
            }
            if (i < range-3)
            {
                (*current++) = inner[i+1];
                (*current++) = inner[i];
                (*current++) = outer[last];
            }
        }

        if (range-3 > last+overload/2)
        {
            (*current++) = inner[range-3];
            (*current++) = outer[last];
            (*current++) = outer[last+overload];
            last += overload;
        }
        if (last != range-1)
        {
            (*current++) = inner[range-3];
            (*current++) = outer[last];
            (*current++) = outer[range-1];
            last += overload;
        }
    }

    memcpy(current,core_pattern,sizeof(core_pattern));
    current+=ARRAYSIZE(core_pattern);
    END
}



template <class GL, unsigned Exponent> void EveFractalMapPatterns<GL,Exponent>::create()
{
    if (created)
        return;
    BEGIN
    created = true;
    uploaded = false;
//    IndexMap::defineBorders();
    createCorePattern();
    unsigned range0 = range;
    while (range0 > 1)
    {
        unsigned range1 = range-1;
        while (range1 > 1)
        {
            unsigned range2 = range-1;
            while (range2 > 1)
            {
                makePattern(range0,range1,range2);
                range2>>=1;
            }
            range1>>=1;
        }
        range0>>=1;
    }
    (*ocurrent++) = current - pattern;

    if (current-pattern > ARRAYSIZE(pattern))
        ERROR_THROW__("bad pattern-creation");

    if (ocurrent-pattern_offset > ARRAYSIZE(pattern_offset))
        ERROR_THROW__("bad pattern-creation ("+IntToStr(ocurrent-pattern_offset)+">"+IntToStr(ARRAYSIZE(pattern_offset))+")");

    END
}

template <class GL, unsigned Exponent> void EveFractalMapPatterns<GL,Exponent>::makePatterns()
{
    if (uploaded)
        return;
    BEGIN
    uploaded = true;
    if (!created)
        create();
    if (GL::indexObject(pattern_buffer,pattern,current-pattern))
        EveStatistics::vram += (current-pattern)*sizeof(*pattern);
    END
}



template <class GL, class ConfigModule>
EveFractalModule<GL,ConfigModule>::Sector::Sector():objects_defined(false)
{
    BEGIN
    EveStatistics::sectors++;
    END
}


template <class GL, class ConfigModule>
bool EveFractalModule<GL,ConfigModule>::Sector::defineSphere(CAbstractSphere<Float>&sphere)
{

    BEGIN
/*    float box[6];
    
    _c3(surface_map,box);
    _c3(surface_map,box+3);
    for (unsigned y = 0; y < range; y+=4)
        for (unsigned x = 0; x <= y; x+=4)
        {
            unsigned index = CFractalIndexMap<Exponent>::getIndex(x,y);
            _oDetDimension(surface_map+index*8,box);
            if (underwater[index])
                _oDetDimension(water_map+index*6,box);
        }
*/
    _center(surface_map,surface_map+10*map.border[1][0],surface_map+10*map.border[2][0],(Float*)sphere.center);
    sphere.radius = 0;
    for (unsigned y = 0; y < range; y+=4)
        for (unsigned x = 0; x <= y; x+=4)
        {
            unsigned index = map.getIndex(x,y);
            sphere.include(surface_map+index*10);
            if (underwater[index])
                sphere.include(water_map+index*6);
        }

    return true;
    END
}


template <class GL, class ConfigModule>
template <class Super, class Norm>
void EveFractalModule<GL,ConfigModule>::Sector::update(Super&super,CFractalSector<Reflection,Norm>*t)
{
    BEGIN
    typedef CFractalSector<Reflection,Norm>    Face;
    typedef typename GL::FloatType  VFloat;

//    typename CFractalSector<Reflection,Norm>::Node*node = t->node;
    bool water = false,
         trees = false;

    VFloat  *map = t->surface_map,*wmap = t->water_map,*tmap = t->tree_map;
    bool *watered = t->underwater;
    Float   up_vector[3],
            domain;
//    logfile<<"[initialized: "+IntToHex((int)t,8)+"]\n";
    unsigned object_layers = EVE_NATIVE_LAYERS;
    if (object_layers <= super.detail_limit)
        object_layers = (unsigned)super.detail_limit+1;

    
    for (unsigned i = 0; i < Face::vertices; i++)
    {
        typename Face::Vertex&v = t->vertex[i];
        Norm::get(v.position,up_vector);

        _c3(v.position, map);                 map+=3;
        _mad(v.position,up_vector,super.tree_height,tmap); tmap+=3;
        _c3(v.normal, map);                   map+=3;
        _c3(v.normal, tmap);                    tmap+=3;
        (*tmap) = ColorMap::apply(super,v,up_vector,map); map+=2;
        
        map[0] = _angleOne(v.position[0],v.position[2]);
        map[1] = atan2f(v.position[1],sqrt(sqr(v.position[0])+sqr(v.position[2])))/M_PI+0.5;
        
        if (i)
        {
            if (vabs(domain-map[0])>0.6)
                if (domain > map[0])
                    map[0]++;
                else
                    map[0]--;
        }
        else
            domain = map[0];

        map+=2;
        
        trees = trees || (*tmap);

        VFloat   temp[3];
        _c3(v.position,temp);
        Norm::set(temp,super.water_height);
        _c3(temp,wmap);                       wmap+=3;
        _c3(up_vector,wmap);                  wmap+=3;

        water |= (*watered++) = (t->vertex[i].data.height <= super.water_height);

        if (t->map.info[i].parent0 != UNSIGNED_UNDEF && !t->objects_defined && t->depth < object_layers)// && rnd < p)
        {
            EveMapObjectReference*obj = super.getObject(t->depth, v.data.fertility, v.data.height, (*tmap)>0.5?0:1.0);
            if (obj)
            {
                obj->layer = t;
                __makeAxisSystem(v.position,up_vector, 1,obj->system);
                t->native_objects.append(obj);
            }
        }
        tmap++;
    }
    t->objects_defined = true;
    //logfile<<"[built: "+IntToHex((int)t,8)+"]\n";
//    t->objects_defined = false;

    if (map != t->surface_map + ARRAYSIZE(t->surface_map) || wmap != t->water_map + ARRAYSIZE(t->water_map) || tmap != t->tree_map + ARRAYSIZE(t->tree_map))
        ERROR_THROW__("creation-error");
    //logfile<<"[checked: "+IntToHex((int)t,8)+"]\n";
    t->water_visible = water;
    t->trees_visible = trees;

    t->reload = true;

    END

}


template <class GL, class ConfigModule>
void EveFractalModule<GL,ConfigModule>::Sector::upload()
{
    BEGIN
    bool    ground_empty = surface_buffer.isEmpty(),
            water_empty = water_buffer.isEmpty(),
            tree_empty = tree_buffer.isEmpty();

    bool    ground_uploaded = GL::vertexObject(surface_buffer,surface_map,ARRAYSIZE(surface_map));
    bool    water_uploaded = water_visible && GL::vertexObject(water_buffer,water_map,ARRAYSIZE(water_map));
    bool    tree_uploaded = trees_visible && GL::vertexObject(tree_buffer,tree_map,ARRAYSIZE(tree_map));

//    logfile<<"[uploaded: "+IntToHex((int)t,8)+"]\n";





    if (ground_empty && ground_uploaded)
        EveStatistics::vram += sizeof(surface_map);
    else
        if (!ground_empty && !ground_uploaded)
            EveStatistics::vram -= sizeof(surface_map);

    if (water_empty && water_uploaded)
        EveStatistics::vram += sizeof(water_map);
    else
        if (!water_empty && !water_uploaded)
            EveStatistics::vram -= sizeof(water_map);

    if (tree_empty && tree_uploaded)
        EveStatistics::vram += sizeof(tree_map);
    else
        if (!tree_empty && !tree_uploaded)
            EveStatistics::vram -= sizeof(tree_map);
    //logfile<<"[finished: "+IntToHex((int)t,8)+"]\n";
    reload = false;
    END
}


template <class GL, class ConfigModule>
template <class Super, class Norm>
void EveFractalModule<GL,ConfigModule>::Sector::updateNormals(Super&super,CFractalSector<Reflection,Norm>*t)
{
    if (!t->surface_map)
        return;
    BEGIN
    typedef CFractalSector<Reflection,Norm>    Face;

    typename GL::FloatType  *map = t->surface_map+3;
    for (unsigned i = 0; i < Face::vertices; i++)
    {
        typename Face::Vertex&v = t->vertex[i];

        _c3(v.normal, map);           map+=10;
    }
    t->reload = true;
    END
}



template <class GL, class ConfigModule> EveFractalModule<GL,ConfigModule>::Sector::~Sector()
{
    BEGIN
    EveStatistics::sectors--;

        if (!tree_buffer.isEmpty())
            EveStatistics::vram -= ARRAYSIZE(tree_map)*sizeof(typename GL::FloatType);

        if (!surface_buffer.isEmpty())
            EveStatistics::vram -= ARRAYSIZE(surface_map)*sizeof(typename GL::FloatType);

        if (!water_buffer.isEmpty())
            EveStatistics::vram -= ARRAYSIZE(water_map)*sizeof(typename GL::FloatType);

        GL::discardObject(surface_buffer);
        GL::discardObject(water_buffer);
        GL::discardObject(tree_buffer);

    END
}




template <class Module, class Norm>
eCastResult EveFractalMapView::cast(CFractalSector<Module,Norm>*triangle)
{
    BEGIN
    
        typedef CFractalSector<Module,Norm> Face;
/*        if (triangle->surface_buffer != GL::emptyVertexObject() && GL::queryVertexObjectSize(triangle->surface_buffer) != sizeof(typename GL::FloatType)*8*Face::vertices)
            ERROR_THROW__("buffer-size mismatch. expected "+IntToStr(sizeof(typename GL::FloatType)*8*Face::vertices)+" but got "+IntToStr(GL::queryVertexObjectSize(triangle->surface_buffer)));*/

        typedef typename Face::FloatType Float;

        Float   cage[8][4],lower[3],upper[3],box0[3]={-1.1,-1.1,-1.1},box1[3]={1.1,1.1,1.1},vector[3];
        Float   delta[3];
        _sub((Float*)triangle->global_sphere.center,camera.location,delta);
        Float   distance = _length(delta);
/*        if (visual_range && distance - triangle->global_sphere.radius> visual_range)// || _intensity(vector,vertex.position)<-0.25)
        {

            END
            return CR_IGNORE;
        }*/

/*        if ((_oneLess(camera.location,triangle->global_box)|| _oneGreater(camera.location,triangle->global_box+3))
            &&*/
        if (!visual_volume.visible((Float*)triangle->global_sphere.center,triangle->global_sphere.radius))
            {
                END
                return CR_IGNORE;
            }

        _div(delta,distance);
        Float blur = velocity*EVE_VELOCITY_BLUR*vmax(0.0,(Float)1.0-1.0*vabs(_dot(movement_direction,delta)));






        if (triangle->depth < EVE_NATIVE_LAYERS)
        {
            triangle->native_objects.reset();
            while (EveMapObjectReference*ref = triangle->native_objects.each())
            {
                EveMapObject*object = ref->origin;
                if (!object)
                    ERROR_THROW__("object origin not defined");
                    
                if (_distance(camera.location,ref->system+12) > 100)
                    continue;

                float absolute_center[3];
                __transform(ref->system,object->center,absolute_center);
                if (!visual_volume.visible(absolute_center,object->radius))
                    continue;
                static CMutex mutex;
                mutex.lock();
                    
                if (object->allocated < object->limit)
                {
                    CVStructureInstance<CVStdDef>*inst = object->instance_field[object->allocated];
                    _c16(ref->system,inst->system);
                    inst->update();
                    object->entity_field[object->allocated]->status = STAT_STATIC_VISIBLE;
                    object->allocated++;
                }
                mutex.release();
            }
        }
        
        

        if (triangle->depth > detail_limit)
        {
            Float dist = distance+blur,
                  radius = _distance(triangle->getCorner(0).position,triangle->getCorner(1).position)/2;
            
            if (dist  < radius*vmax(triangle->depth/5.0*lod,0.9)*1.5)
            {
                END
                return CR_FOCUS;
            }
        }

        triangle->super->visible_sectors++;

        if (triangle->depth <= 2)
            triangle->dropChildren();
        if (triangle->super->most_detail > triangle->depth)
            triangle->super->most_detail = triangle->depth;
        EveStatistics::rendered++;
    END
    return CR_INSERT;
}








template <class Face> static unsigned getPattern(Face*sector)
{
    BEGIN
        unsigned d0 = sector->vis0-sector->depth, d1 = sector->vis1-sector->depth, d2 = sector->vis2-sector->depth;
        if (d0 >= Face::Size)
            d0 = Face::Size-1;
        if (d1 >= Face::Size)
            d1 = Face::Size-1;
        if (d2 >= Face::Size)
            d2 = Face::Size-1;
        return  d0*Face::Size*Face::Size + d1*Face::Size + d2;
    END
}


template <class Map> static void renderLayer(Map&map, unsigned layer)
{
    BEGIN
    typedef typename Map::EveGL     GL;
    typedef typename Map::Sector    Sector;
    for (unsigned i = 0; i < map.sector_count[layer]; i++)
    {
        Sector*sector = map.sector_buffer[layer][i];
        if (sector->reload)
            sector->upload();

/*
        glDisable(GL_LIGHTING);
        glColor3f(1,0,0);
        glBegin(GL_LINE_LOOP);
            for (BYTE k = 0; k < 3; k++)
                for (unsigned i = 0; i < sector->range; i++)
                    glVertex3fv(sector->vertex[sector->border[k][i]].position);
        
        
        glEnd();
        glColor3f(1,1,1);
        
        glEnable(GL_LIGHTING);*/

/*            glDisable(GL_TEXTURE_2D);
            glBegin(GL_TRIANGLES);
                glNormal3fv(sector->getCorner(0).normal);
                glVertex3fv(sector->getCorner(0).position);
                glNormal3fv(sector->getCorner(1).normal);
                glVertex3fv(sector->getCorner(1).position);
                glNormal3fv(sector->getCorner(2).normal);
                glVertex3fv(sector->getCorner(2).position);

            glEnd();
            glBegin(GL_POINTS);
                for (unsigned i = 0; i < sector->vertices; i++)
                {
                    glNormal3fv(sector->vertex[i].normal);
                    glVertex3fv(sector->vertex[i].position);
                }
            
            glEnd();*/

        #ifdef FRAC_DISABLE_PATTERNS
            unsigned p = 0;
        #else
            unsigned p = getPattern(sector);
        #endif
/*        if (p >= Sector::Size*Sector::Size*Sector::Size)
            ERROR_THROW__("bad pattern");
        for (unsigned j = Map::pattern_offset[p]; j < Map::pattern_offset[p+1]; j++)
            if (Map::pattern[j]>= Map::Sector::vertices)
                ERROR_THROW__("bad pattern index("+IntToStr(j)+"): "+IntToStr(Map::pattern[j])+"/"+IntToStr(Map::Sector::vertices));*/
        #ifdef EVE_VERTEX_UPLOAD_TEST
        if (!sector->surface_buffer.isEmpty())
        {
            typename GL::FloatType  field[Sector::vertices*10];
            typename GL::IndexType  ifield[Map::pattern_exponent*Map::pattern_exponent*Map::pattern_exponent*Sector::range*Sector::range*3];
            unsigned    vlen = GL::getContent(sector->surface_buffer,field,ARRAYSIZE(field)),
                        ilen = GL::getContent(map.pattern_buffer,ifield,ARRAYSIZE(ifield));
            if (vlen != ARRAYSIZE(field))
                ERROR_THROW__("size-mismatch");
            if (Map::pattern_offset[p+1] > ilen)
                ERROR_THROW__("pattern-error");
            for (unsigned j = Map::pattern_offset[p]; j < Map::pattern_offset[p+1]; j++)
                if (ifield[j] >= Sector::vertices)
                    ERROR_THROW__("index-error");
//            continue;
        }
        #endif
        GL::bindVertices(sector->surface_map, sector->surface_buffer,6+2);

        GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
    }
    END
}


template <class Map> EveFractalMap<Map>::EveFractalMap():
        visual_object_range(100),
        fine_ground_scale(0.01),large_ground_scale(0.1),fine_water_scale(0.01),large_water_scale(0.1),fine_water_speed(0.01),
        large_water_speed(0.1),ground_config(3),water_config(4),
        tree_config(3)
{
    Map::water_height = 10;
    Map::tree_height = 1.0;
    
    ground_config.loadDefaults(true,true,false);

    for (unsigned i = 3; i < ground_config.layers; i++)
    {
        ground_config.layer[i].combiner = 0x2100;
        ground_config.layer[i].flags = 0;
        ground_config.layer[i].section.offset = 0;
        ground_config.layer[i].section.count = 0;
    }

    ground_config.layer[0].combiner = 0x2100;
    ground_config.layer[0].flags = CLAMP_X_FLAG|CLAMP_Y_FLAG;
    ground_config.layer[0].section.offset = 6;
    ground_config.layer[0].section.count = 2;
    ground_config.layer[1].combiner = 0x2100;
    ground_config.layer[1].flags = EVE_CUSTOM_SYSTEM_FLAG;
    ground_config.layer[1].section.offset = 0;
    ground_config.layer[1].section.count = ati_bug?2:3;
    ground_config.layer[2].combiner = 0x2100;
    ground_config.layer[2].flags = 0;
    ground_config.layer[2].section.offset = 8;
    ground_config.layer[2].section.count = 2;
    ground_config.vertex_band = 10;
    
    
    tree_config.loadDefaults(true,true,false);
    tree_config.layer[0].combiner = 0x2100;
    tree_config.layer[0].flags = EVE_CUSTOM_SYSTEM_FLAG;
    tree_config.layer[0].section.offset = 0;
    tree_config.layer[0].section.count = ati_bug?2:3;
    tree_config.layer[1] = tree_config.layer[0];
    tree_config.layer[2].combiner = 0x2100;
    tree_config.layer[2].flags = CLAMP_X_FLAG|CLAMP_Y_FLAG;
    tree_config.layer[2].section.offset = 6;
    tree_config.layer[2].section.count = 1;
//    _v4(tree_config.specular,1,1,1,1);
    tree_config.shininess = 0.5;
    tree_config.alpha_border = 0.5;
    tree_config.flags = EVE_LOAD_COLORS_FLAG;
    tree_config.vertex_band = 7;

    water_config.loadDefaults(true,true,false);

    _v4(water_config.specular,1,1,1,1);
    water_config.shininess = 0.25;
    water_config.flags = EVE_LOAD_COLORS_FLAG;

    water_config.layer[0].flags = EVE_CUSTOM_SYSTEM_FLAG;
    water_config.layer[0].section.offset = 0;
    water_config.layer[0].section.count = ati_bug?2:3;

    water_config.layer[1].flags = EVE_CUSTOM_SYSTEM_FLAG;
    water_config.layer[1].section.offset = 0;
    water_config.layer[1].section.count = ati_bug?2:3;

    water_config.layer[2].flags = EVE_CUSTOM_SYSTEM_FLAG;
    water_config.layer[2].section.offset = 0;
    water_config.layer[2].section.count = ati_bug?2:3;

    water_config.layer[3].flags = EVE_CUSTOM_SYSTEM_FLAG;
    water_config.layer[3].section.offset = 0;
    water_config.layer[3].section.count = ati_bug?2:3;

    water_config.vertex_band = 6;


}





template <class GL, class ConfigModule>
EveMapObjectReference* EveFractalModule<GL,ConfigModule>::Map::getObject(unsigned depth, const Float&fertility, const Float&height, float random)
{
    BEGIN

    float probability_sum(0);
    for (unsigned i = 0; i < native_objects[depth]; i++)
    {
        EveMapObject*object = native_objects[depth][i];
        object->p =   //normalDistribution(fertility,object->ideal_fertility,object->fertility_tolerance)
                        fertility
//                    *normalDistribution(height,object->ideal_height,object->height_tolerance)
                    *object->general_probability;
        probability_sum+=object->p;
    }
    if (probability_sum<1)
        probability_sum = 1;

    for (unsigned i = 0; i < native_objects[depth]; i++)
    {
        EveMapObject*object = native_objects[depth][i];
        object->p /= probability_sum;
        if (random < object->p)
        {
            EveMapObjectReference*result = SHIELDED(new EveMapObjectReference());
            result->origin = object;
            result->layer = NULL;
            END
            return result;
        }
        random -= object->p;
    }
    END
    return NULL;
}

template <class Map> void EveFractalMap<Map>::removeFromMap(EveMapObjectReference*reference)
{
    if (!reference->layer)
        return;
    reference->layer->native_objects.drop(reference);
}


template <class Map> EveMapObject* EveFractalMap<Map>::insertNativeObject(const CString&filename,unsigned layer,float ideal_fertility, float fertility_tolerance, float ideal_height, float height_tolerance, float general_probability, unsigned instances)
{
    BEGIN
    if (layer >= EVE_NATIVE_LAYERS)
        layer = EVE_NATIVE_LAYERS-1;
    EveMapObject*object = new EveMapObject();
    if (!object->structure.loadFromFile(filename.c_str()))
    {
        delete object;
        END
        return NULL;
    }

    object->ideal_fertility = ideal_fertility;
    object->fertility_tolerance = fertility_tolerance;
    object->ideal_height = ideal_height;
    object->height_tolerance = height_tolerance;
    object->general_probability = general_probability;
    object->p = 0;
    object->allocated = 0;
    object->prev_allocated = 0;
    object->limit = instances;
    
    float dim[6];
    object->structure.extractDimensions(dim);
    _center(dim,dim+3,object->center);
    object->radius = object->structure.extractRadiusAround(object->center);
//    object->collision_object = abstractCapsule(CPoint<Float>(0,dim[1],0),CPoint<Float>(0,dim[4]-collision_width,0),collision_width);

    
    
    Map::native_objects[layer].append(object);
    for (unsigned i = 0; i < instances; i++)
        object->entity_field.append(Map::ModuleReflection::Reflection::scenery.embed(object->instance_field.append(object->structure.createInstance()),STAT_DISABLED));
    END
    return object;
}

template <class Map> void EveFractalMap<Map>::renderObjects()
{
    BEGIN

    for (unsigned i = 0; i < EVE_NATIVE_LAYERS; i++)
    {
        Map::native_objects[i].reset();
        while (EveMapObject*object =Map::native_objects[i].each())
        {
            for (unsigned i = object->allocated; i < object->prev_allocated; i++)
                object->entity_field[i]->status = STAT_DISABLED;
            object->prev_allocated = object->allocated;
            object->allocated = 0;
        }
    }

    
    Map::ModuleReflection::scenery.render(Map::camera,visual_object_range);
    END

}


template <class Map>    void EveFractalMap<Map>::renderLandscape()
{
    BEGIN

    typedef typename Map::EveGL  GL;

    EveStatistics::rendered = 0;

    most_detail = UNSIGNED_UNDEF;
    Map::ModuleReflection::scenery.lock();
    trace(eveTiming.NOW64,60);  // old style - *brrrrr* shiver me timbers. faster anyways :P
    Map::ModuleReflection::scenery.unlock();

    Float   up[3],user[3];
    _c3(user_location,user);
    Map::Norm::get(user,up);
    
    Float sys[16],projection[3],inv[16],temp[3];
    _add(up,texture_up,projection);
    _mad(texture_root,up,(_dot(user_location,up)-_dot(texture_root,up))/_dot(up));
    _mad(texture_x,projection,-_dot(texture_x,up)/_dot(projection,up));
    _c3(up,texture_up);
    _cross(texture_x,up,texture_y);
    _normalize(texture_x);
    _normalize(texture_y);
    
    //shiver me timbers. the seas have got me - yar.

    _c3(texture_x,sys);
    _c3(texture_y,sys+4);
    _c3(texture_up,sys+8);
    _c3(texture_root,sys+12);
    sys[3] = sys[7] = sys[11] = 0;
    sys[15] = 1;
    __invertSystem(sys,inv);
    
    __transform(inv,user_location,temp);
    _mad(texture_root,texture_x,(Float)((__int64)(temp[0]/large_ground_scale))*large_ground_scale);
    _mad(texture_root,texture_y,(Float)((__int64)(temp[1]/large_ground_scale))*large_ground_scale);      //problem solved*/
    
    
    _c16(inv,fine_ground_system);
    _div(fine_ground_system,fine_ground_scale);
    _div(fine_ground_system+4,fine_ground_scale);
    _div(fine_ground_system+8,fine_ground_scale);
    _div(fine_ground_system+12,fine_ground_scale);

    _c16(inv,large_ground_system);
    _div(large_ground_system,large_ground_scale);
    _div(large_ground_system+4,large_ground_scale);
    _div(large_ground_system+8,large_ground_scale);
    _div(large_ground_system+12,large_ground_scale);

    _c16(inv,fine_water_system_a);
    _mad(fine_water_system_a+12,fine_water_system_a,fine_water_speed*eveTiming.now);
    _div(fine_water_system_a,fine_water_scale*1.01);
    _div(fine_water_system_a+4,fine_water_scale*1.01);
    _div(fine_water_system_a+8,fine_water_scale*1.01);
    _div(fine_water_system_a+12,fine_water_scale*1.01);

    _c16(inv,fine_water_system_b);
    _mad(fine_water_system_b+12,fine_water_system_b,-0.5*fine_water_speed*eveTiming.now);
    _mad(fine_water_system_b+12,fine_water_system_b+4,0.5*fine_water_speed*eveTiming.now);
    _div(fine_water_system_b,fine_water_scale);
    _div(fine_water_system_b+4,fine_water_scale);
    _div(fine_water_system_b+8,fine_water_scale);
    _div(fine_water_system_b+12,fine_water_scale);


    _c16(inv,large_water_system_a);
    _mad(large_water_system_a+12,large_water_system_a,-large_water_speed*eveTiming.now);
    _div(large_water_system_a,large_water_scale*1.01);
    _div(large_water_system_a+4,large_water_scale*1.01);
    _div(large_water_system_a+8,large_water_scale*1.01);
    _div(large_water_system_a+12,large_water_scale*1.01);

    _c16(inv,large_water_system_b);
    _mad(large_water_system_b+12,large_water_system_b,0.5*large_water_speed*eveTiming.now);
    _mad(large_water_system_b+12,large_water_system_b+4,0.5*large_water_speed*eveTiming.now);
    _div(large_water_system_b,large_water_scale);
    _div(large_water_system_b+4,large_water_scale);
    _div(large_water_system_b+8,large_water_scale);
    _div(large_water_system_b+12,large_water_scale);


    if (ground_config.layers >= 2)
        ground_config.layer[1].system = fine_ground_system;

    tree_config.layer[0].system = fine_ground_system;
    tree_config.layer[1].system = large_ground_system;

    GL::enterSubSystem(system);

    GL::bindMaterial(ground_config,texture);
    GL::bindIndices(pattern,pattern_buffer);

    for (BYTE k = most_detail; k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
        for (unsigned i = 0; i < sector_count[k]; i++)
        {
            typename Map::Sector*sector = sector_buffer[k][i];
            if (sector->reload)
                sector->upload();

            #ifdef FRAC_DISABLE_PATTERNS
                unsigned p = 0;
            #else
                unsigned p = getPattern(sector);
            #endif
            #ifdef EVE_VERTEX_UPLOAD_TEST
            if (!sector->surface_buffer.isEmpty())
            {
                typename GL::FloatType  field[Sector::vertices*10];
                typename GL::IndexType  ifield[Map::pattern_exponent*Map::pattern_exponent*Map::pattern_exponent*Sector::range*Sector::range*3];
                unsigned    vlen = GL::getContent(sector->surface_buffer,field,ARRAYSIZE(field)),
                            ilen = GL::getContent(map.pattern_buffer,ifield,ARRAYSIZE(ifield));
                if (vlen != ARRAYSIZE(field))
                    ERROR_THROW__("size-mismatch");
                if (Map::pattern_offset[p+1] > ilen)
                    ERROR_THROW__("pattern-error");
                for (unsigned j = Map::pattern_offset[p]; j < Map::pattern_offset[p+1]; j++)
                    if (ifield[j] >= Sector::vertices)
                        ERROR_THROW__("index-error");
    //            continue;
            }
            #endif
            GL::bindVertices(sector->surface_map, sector->surface_buffer,10,CLOCATION);

            GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
        }


    GL::unbindAll();
    GL::exitSubSystem();
    END
}

template <class Map>    void EveFractalMap<Map>::renderTreeLayer()
{
    BEGIN
    typedef typename Map::EveGL  GL;
    Texture textures[] = {fine_tree_tex,large_tree_tex,transparency[0]};
    GL::enterSubSystem(system);
    tree_config.flags ^= MASK_FLAG;
    GL::depthMask(false);
    GL::bindMaterial(tree_config,textures);
    GL::bindIndices(pattern, pattern_buffer);
    for (BYTE k = most_detail; k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
    {
        textures[2] = transparency[3-clamped(top_level-k,0,3)];
        GL::bindMaterial(tree_config,textures);
        for (unsigned i = 0; i < sector_count[k]; i++)
        {
            typename Map::Sector*sector = sector_buffer[k][i];
            if (sector->reload)
                sector->upload();

            if (!sector->trees_visible)
                continue;
            #ifdef FRAC_DISABLE_PATTERNS
                unsigned p = 0;
            #else
                unsigned p = getPattern(sector);
            #endif
            GL::bindVertices(sector->tree_map, sector->tree_buffer,7,CLOCATION);
            GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
        }
    }
    
    GL::depthMask(true);
    tree_config.flags |= MASK_FLAG;
    textures[2] = transparency[3];
    GL::bindMaterial(tree_config,textures);
    for (BYTE k = 0; k < 4; k++)
    for (unsigned i = 0; i < sector_count[k]; i++)
    {
            typename Map::Sector*sector = sector_buffer[k][i];
            if (sector->reload)
                sector->upload();

            if (!sector->trees_visible)
                continue;
            #ifdef FRAC_DISABLE_PATTERNS
                unsigned p = 0;
            #else
                unsigned p = getPattern(sector);
            #endif
            GL::bindVertices(sector->tree_map, sector->tree_buffer,7,CLOCATION);
            GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
    }
/*    tree_config.flags ^= MASK_FLAG;
    GL::bindMaterial(tree_config,textures);
    for (BYTE k = vmax(most_detail,4); k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
        for (unsigned i = 0; i < sector_count[k]; i++)
        {
            typename Map::Sector*sector = sector_buffer[k][i];
            if (!sector->trees_visible)
                continue;
            #ifdef FRAC_DISABLE_PATTERNS
                unsigned p = 0;
            #else
                unsigned p = getPattern(sector);
            #endif
            GL::bindVertices(sector->tree_map, sector->tree_buffer,7);
            GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
        }
*/
    GL::unbindAll();
    GL::exitSubSystem();
    END
}

template <class Map>    void EveFractalMap<Map>::renderWater()
{
    BEGIN
    typedef typename Map::EveGL GL;
    if (water_config.layers >= 1)
        water_config.layer[0].system = fine_water_system_a;

    if (water_config.layers >= 2)
        water_config.layer[1].system = fine_water_system_b;
    if (water_config.layers >= 3)
        water_config.layer[2].system = large_water_system_a;
    if (water_config.layers >= 4)
        water_config.layer[3].system = large_water_system_b;

    typename GL::TextureObject  temp[4] = {fine_water_tex,fine_water_tex,large_water_tex,large_water_tex};

    GL::enterSubSystem(system);
    

    GL::bindMaterial(water_config,temp);
    GL::bindIndices(pattern, pattern_buffer);
    for (BYTE k = most_detail; k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
            for (unsigned i = 0; i < sector_count[k]; i++)
            {
                typename Map::Sector*sector = sector_buffer[k][i];
                if (sector->reload)
                    sector->upload();

                if (!sector->water_visible)
                    continue;
                #ifdef FRAC_DISABLE_PATTERNS
                    unsigned p = 0;
                #else
                    unsigned p = getPattern(sector);
                #endif
                GL::bindVertices(sector->water_map, sector->water_buffer,6,CLOCATION);
                GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
            }
    GL::unbindAll();
    GL::exitSubSystem();

    END
}


template <class Map>  void  EveFractalMap<Map>::render()
{
    BEGIN
    renderLandscape();
    renderWater();
    renderObjects();
    END
}



template <class Map>    EveMapObjectReference*EveFractalMap<Map>::detectObjectCollision(const Float last_position[3], const Float position[3], Float radius, Float force_out[3])
{
/*    CAbstractHull<Float>    local = abstractCapsule(CPoint<Float>(last_position),CPoint<Float>(position),radius);
//    ShowMessage(local.toString());
    typename Map::Sector* buffer[0x100];
    unsigned len(0);

    unsigned object_layers = EVE_NATIVE_LAYERS;
    if (object_layers < detail_limit)
        object_layers = detail_limit;

    Map::getVerticallyGoverning(position,object_layer,buffer,len,ARRAYSIZE(buffer));
    for (unsigned b = 0; b < len; b++)
        for (unsigned i = 0; i < Map::Sector::vertices; i++)
            if (buffer[b]->object[i] && buffer[b]->object[i]->instance && buffer[b]->object[i]->collision_object.detectMaximumIndentation(local,force_out))
                return buffer[b]->object[i];*/
    return NULL;
}


template <class Map>    bool EveFractalMap<Map>::intersectsVisibleMap(const Float p0[3], const Float p1[3])
{
    Float d[3],distance;
    _sub(p1,p0,d);
    distance = _length(d);
    _div(d,distance);

    for (unsigned layer = 0; layer <= top_level; layer++)
    {
        for (unsigned i = 0; i < sector_count[layer]; i++)
        {
            typename Map::Sector*sector = sector_buffer[layer][i];
            if (sector->local_sphere.intersectedBy(p0,p1))
            {
                #ifdef FRAC_DISABLE_PATTERNS
                    unsigned p = 0;
                #else
                    unsigned p = getPattern(sector);
                #endif
                for (unsigned j = Map::pattern_offset[p]; j < Map::pattern_offset[p+1]; j+=3)
                    if (_oDetectOpticalIntersection(sector->vertex[Map::pattern[j]].position,sector->vertex[Map::pattern[j+1]].position,sector->vertex[Map::pattern[j+2]].position,p0,d,distance))
                        return true;
            }
        }
    }
    return false;
}

template <class Map>    unsigned EveFractalMap<Map>::extractFaces(const Float box[6], typename Map::Point**field, unsigned max_triangles)
{
    typename Map::Point **out = field,
                        **limit = field+max_triangles*3;
    unsigned cnt = 0;
    for (unsigned layer = 0; layer <= top_level; layer++)
    {
        for (unsigned i = 0; i < sector_count[layer]; i++)
        {
            typename Map::Sector*sector = sector_buffer[layer][i];
            if (_oneGreater(sector->local_box,box+3) || _oneLess(sector->local_box+3,box))
                continue;
            #ifdef FRAC_DISABLE_PATTERNS
                unsigned p = 0;
            #else
                unsigned p = getPattern(sector);
            #endif
            for (unsigned j = Map::pattern_offset[p]; j < Map::pattern_offset[p+1]; j+=3)
            {
                typename Map::Point *p0 = sector->vertex + Map::pattern[j],
                                    *p1 = sector->vertex + Map::pattern[j+1],
                                    *p2 = sector->vertex + Map::pattern[j+2];
                if (
                    (!_oneLess(p0->position,box) && !_oneGreater(p0->position,box+3))
                    ||
                    (!_oneLess(p1->position,box) && !_oneGreater(p1->position,box+3))
                    ||
                    (!_oneLess(p2->position,box) && !_oneGreater(p2->position,box+3))
                   )
                {
                    (*out++) = p0;
                    (*out++) = p1;
                    (*out++) = p2;
                    if (out == limit)
                        return max_triangles;
                }
            }
        }
    }
    return (out-field)/3;
}


template <class Map> void EveFractalMap<Map>::initTextures()
{
    CImage  image(64,1,4);
    for (BYTE k = 0; k < 4; k++)
    {
        for (int i = 0; i < 64; i++)
            image.set(i,0,255,255,255,(BYTE)clamped(128+(Float)(i-32.0)*10.0/(0.5*k+1.0),0,255));
        Map::EveGL::textureObject(transparency[k],&image,1,TM_TRILINEAR);
    }
}






template <class GL, class ConfigModule> EveFractalCloudModule<GL,ConfigModule>::Sector::Sector()
{
    EveStatistics::sectors++;
}

template <class GL, class ConfigModule> EveFractalCloudModule<GL,ConfigModule>::Sector::~Sector()
{
    EveStatistics::sectors--;

    if (!floor_buffer.isEmpty())
        EveStatistics::vram -= vertices*7*sizeof(typename GL::FloatType);
    if (!ceiling_buffer.isEmpty())
        EveStatistics::vram -= vertices*7*sizeof(typename GL::FloatType);

    GL::discardObject(ceiling_buffer);
    GL::discardObject(floor_buffer);
}


template <class GL, class ConfigModule>
bool EveFractalCloudModule<GL,ConfigModule>::Sector::defineSphere(CAbstractSphere<Float>&sphere)
{
    BEGIN
/*    Float box[6];
    _c3(ceiling_map,box);
    _c3(ceiling_map,box+3);
    for (unsigned y = 0; y < range; y+=2)
        for (unsigned x = 0; x <= y; x+=2)
        {
            unsigned index = CFractalIndexMap<Exponent>::getIndex(x,y);
            _oDetDimension(ceiling_map+index*7,box);
            if (ceiling_map[index*7+6]>0)
                _oDetDimension(floor_map+index*7,box);
        }
        
    _center(box,box+3,(Float*)sphere.center);
*/
    _center(ceiling_map,ceiling_map+7*map.border[1][0],ceiling_map+7*map.border[2][0],(Float*)sphere.center);
    sphere.radius = 0;
    for (unsigned y = 0; y < range; y+=2)
        for (unsigned x = 0; x <= y; x+=2)
        {
            unsigned index = map.getIndex(x,y);
            sphere.include(ceiling_map+index*7);
            if (ceiling_map[index*7+6]>0)
                sphere.include(floor_map+index*7);
        }

    return true;
    END
}


template <class GL, class ConfigModule>
template <class Super, class Norm>
void             EveFractalCloudModule<GL,ConfigModule>::Sector::update(Super&super,CFractalSector<Reflection,Norm>*face)
{
    BEGIN
    typedef CFractalSector<Reflection,Norm>    Face;


    bool visible = false;

    typename GL::FloatType  *ceiling = face->ceiling_map,*floor = face->floor_map;
//    bool*vmap = face->visible_map;
    for (unsigned i = 0; i < Face::vertices; i++)
    {
        typename Face::Vertex&v = face->vertex[i];
        Float   mirrored[3],normal[3],
                h = Norm::get(v.position),
                darkness = clamped((h -super.cloud_height)/super.cloud_blur,0,1),
                visibility = clamped((h -super.cloud_height)/super.cloud_blur+0.5,0,1);
        Norm::get(v.position,normal);
        
//        (*vmap++) = (h > super.cloud_height);
        visible = visible||visibility>0;

        Float mirrored_position[3];
        _c3(v.position,mirrored_position);
        Norm::set(mirrored_position,super.cloud_height);
        _c3(mirrored_position,floor); floor+=3;
        _c3(v.position,ceiling); ceiling+=3;

        //_reflect(v.position,normal,v.normal,floor); _normalize(floor);
        _interpolate(v.normal,normal,darkness*0.5,floor);
        _mult(floor,1.0-darkness*0.3); floor+=3;
        (*floor++) = visibility;
        _c3(v.normal,ceiling); ceiling+=3;
        (*ceiling++) = visibility;

    }
    face->visible = visible;
    
    face->reload = true;

    if (floor != face->floor_map + ARRAYSIZE(face->floor_map) || ceiling != face->ceiling_map + ARRAYSIZE(face->ceiling_map))
        ERROR_THROW__("creation-error");

    END
}

template <class GL, class ConfigModule>
void             EveFractalCloudModule<GL,ConfigModule>::Sector::upload()
{
    BEGIN

    bool    floor_empty = floor_buffer.isEmpty(),
            ceiling_empty = ceiling_buffer.isEmpty(),
    #ifndef EVE_VERTEX_UPLOAD_TEST
            floor_uploaded = visible && GL::vertexObject(floor_buffer,floor_map,ARRAYSIZE(floor_map)),
            ceiling_uploaded = visible && GL::vertexObject(ceiling_buffer,ceiling_map,ARRAYSIZE(ceiling_map));
    #else
            floor_uploaded = false,
            ceiling_uploaded = false;
            if (upload_counter)
            {
                floor_uploaded = visible && GL::vertexObject(floor_buffer,floor_map,ARRAYSIZE(floor_map)),
                ceiling_uploaded = visible && GL::vertexObject(ceiling_buffer,ceiling_map,ARRAYSIZE(ceiling_map));
                upload_counter--;
            }

    #endif

    if (floor_empty && floor_uploaded)
        EveStatistics::vram += sizeof(floor_map);
    else
        if (!floor_empty && !floor_uploaded)
            EveStatistics::vram -= sizeof(floor_map);

    if (ceiling_empty && ceiling_uploaded)
        EveStatistics::vram += sizeof(ceiling_map);
    else
        if (!ceiling_empty && !ceiling_uploaded)
            EveStatistics::vram -= sizeof(ceiling_map);
    reload = false;
    END
}




template <class GL, class ConfigModule>
template <class Super, class Norm>
void  EveFractalCloudModule<GL,ConfigModule>::Sector::updateNormals(Super&super,CFractalSector<Reflection,Norm>*face)
{
    BEGIN
    if (!face->visible)
        return;
    typedef CFractalSector<Reflection,Norm>    Face;

    typename GL::FloatType  *ceiling = face->ceiling_map,*floor = face->floor_map;
    for (unsigned i = 0; i < Face::vertices; i++)
    {
        typename Face::Vertex&v = face->vertex[i];
        Float   mirrored[3],normal[3],
                h = Norm::get(v.position),
                darkness = clamped((h -super.cloud_height)/super.cloud_blur,0,1);
        Norm::get(v.position,normal);

            floor+=3;
            _interpolate(v.normal,normal,darkness*0.5,floor);
            _mult(floor,1.0-darkness*0.3); floor+=4;

//            _reflect(v.position,normal,v.normal,floor); _normalize(floor); floor+=4;
            ceiling+=3;
            _c3(v.normal,ceiling); ceiling+=4;
    }


    bool    floor_empty = face->floor_buffer.isEmpty(),
            ceiling_empty = face->ceiling_buffer.isEmpty(),
    #ifndef EVE_VERTEX_UPLOAD_TEST
            floor_uploaded = face->visible && GL::vertexObject(face->floor_buffer,face->floor_map,vertices*7),
            ceiling_uploaded = face->visible && GL::vertexObject(face->ceiling_buffer,face->ceiling_map,vertices*7);
    #else
            floor_uploaded = false,
            ceiling_uploaded = false;
            if (upload_counter)
            {
                floor_uploaded = face->visible && GL::vertexObject(face->floor_buffer,face->floor_map,vertices*7),
                ceiling_uploaded = face->visible && GL::vertexObject(face->ceiling_buffer,face->ceiling_map,vertices*7);
                upload_counter--;
            }
    #endif

    if (floor_empty && floor_uploaded)
        EveStatistics::vram += sizeof(Float)*vertices*7;
    else
        if (!floor_empty && !floor_uploaded)
            EveStatistics::vram -= sizeof(Float)*vertices*7;

    if (ceiling_empty && ceiling_uploaded)
        EveStatistics::vram += sizeof(Float)*vertices*7;
    else
        if (!ceiling_empty && !ceiling_uploaded)
            EveStatistics::vram -= sizeof(Float)*vertices*7;


    END
}



template <class GL, class ConfigModule>
template <class Module, class Norm>
inline void EveFractalCloudModule<GL,ConfigModule>::Interpolator::interpolate(const CFractalPoint<typename Module::Sector::FloatType>&v0,
                                            const CFractalPoint<typename Module::Sector::FloatType>&v1,
                                            CFractalPoint<typename Module::Sector::FloatType>&result,
                                            unsigned index, const TFractalInterpolatorContext<Module,Norm>&context)
{
    typedef typename Module::Sector::FloatType Float;
    Float level = context.depth;
   // Vertex  result;
    Float   delta[3],distance(_distance(v0.position,v1.position)),
            normal0[3],normal1[3],direction0[3],direction1[3],control0[3],control1[3];
    _sub(v1.position,v0.position,delta);
    _cross(v0.normal,delta,normal0);
    _cross(v1.normal,delta,normal1);
    _cross(v0.normal,normal0,direction0);
    _cross(v1.normal,normal1,direction1);
    Float balance = v0.data.height/v1.data.height;
    _setLen(direction0,-distance*FRACTAL_NURBS_CONST);
    _setLen(direction1,distance*FRACTAL_NURBS_CONST);
    _add(v0.position,direction0,control0);
    _add(v1.position,direction1,control1);
    _resolveNURBS(v0.position,control0,control1,v1.position,0.5,result.position);
    result.data.height = Norm::get(result.position);
    result.data.fertility = 0.5;
    result.data.appearance = 0.5;



    Float d;//,var = clamped((result.data.height-context.super->bottom.height+context.super->variance/10.0f)/(context.super->variance/10.0f),0,1);

    if (level > 4)
        d = distance/5*context.super->variance;//(level+1);
    else
        d = distance/3*context.super->variance;//(level+1);
/*    else
        d = (vpow(var,1.5) + vpow(var,19))* distance/10*context.super->variance*(6+vmin(level,6)/6.0);*/

    result.data.height += context.node->random(index*3+2)*d;
    Norm::set(result.position,result.data.height);
}




template <class Map> EveFractalClouds<Map>::EveFractalClouds():cloud_config(1)
{
    Map::cloud_height = 10;
    Map::cloud_blur = 1;
    
    cloud_config.loadDefaults();
    cloud_config.flags |= EVE_LOAD_COLORS_FLAG;
    _set(cloud_config.ambient,0.1);
    _set(cloud_config.diffuse,1.0);
    _set(cloud_config.specular,0.0);
    cloud_config.vertex_band = 7;
    cloud_config.layer[0].section.offset = 6;
    cloud_config.layer[0].section.count = 1;
    cloud_config.layer[0].flags |= CLAMP_X_FLAG;
}

template <class Map> void EveFractalClouds<Map>::initTextures()
{
    CImage  image(64,1,4);
    for (BYTE k = 0; k < 4; k++)
    {
        for (int i = 0; i < 64; i++)
            image.set(i,0,255,255,255,(BYTE)clamped(128+(Float)(i-32.0)*10.0/(0.5*k+1.0),0,255));
        Map::EveGL::textureObject(cloud_texture[k],&image,1,TM_TRILINEAR);
    }
}


template <class Map> void EveFractalClouds<Map>::render(bool floor, bool ceiling)
{
    typedef typename Map::EveGL GL;
    most_detail = UNSIGNED_UNDEF;
    trace(eveTiming.NOW64,60);  // old style - *brrrrr* shiver me timbers. faster anyways :P

    GL::enterSubSystem(system);
    GL::bindMaterial(cloud_config,cloud_texture);
    GL::bindIndices(pattern, pattern_buffer);
    
    if (floor)
    {
        GL::cullInverse();

        for (BYTE k = most_detail; k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
            if (sector_count[k])
            {
                for (unsigned i = 0; i < sector_count[k]; i++)
                {
                    typename Map::Sector*sector = sector_buffer[k][i];
                    if (sector->reload)
                        sector->upload();

                    if (!sector->visible)
                        continue;
                    #ifdef FRAC_DISABLE_PATTERNS
                        unsigned p = 0;
                    #else
                        unsigned p = getPattern(sector);
                    #endif
                    GL::bindVertices(sector->floor_map, sector->floor_buffer,7,CLOCATION);
                    GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
                }
            }
    }
    if (ceiling)
    {
        GL::cullNormal();

        for (BYTE k = most_detail; k <= top_level && k <= most_detail+EVE_FRACTAL_DETAIL_RANGE; k++)
            if (sector_count[k])
            {
                GL::bindMaterial(cloud_config,cloud_texture+3-clamped(top_level-k,0,3));
                for (unsigned i = 0; i < sector_count[k]; i++)
                {
                    typename Map::Sector*sector = sector_buffer[k][i];
                    if (sector->reload)
                        sector->upload();
                    if (!sector->visible)
                        continue;
                    #ifdef FRAC_DISABLE_PATTERNS
                        unsigned p = 0;
                    #else
                        unsigned p = getPattern(sector);
                    #endif
                    GL::bindVertices(sector->ceiling_map, sector->ceiling_buffer,7,CLOCATION);
                    GL::render(Map::pattern_offset[p],Map::pattern_offset[p+1]-Map::pattern_offset[p]);
                }
            }
    }
    else
        GL::cullNormal();
    GL::unbindAll();
    GL::exitSubSystem();
}


#endif
