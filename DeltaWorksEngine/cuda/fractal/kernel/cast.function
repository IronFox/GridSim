	DEVICE_RESOURCE(TVertex,v0) = surface.vertex[triangle_indices[linear*3]];
	DEVICE_RESOURCE(TVertex,v1) = surface.vertex[triangle_indices[linear*3+1]];
	DEVICE_RESOURCE(TVertex,v2) = surface.vertex[triangle_indices[linear*3+2]];

	float	d0[3],d1[3],n[3],dif[3],n0[3],n1[3],cross_point[3];

	dvSub(v1.position,v0.position,d0);
	dvSub(v2.position,v0.position,d1);
	dvCross(d0,d1,n);
	dvSub(v0.position,b,dif);
	float	sub_alpha = dvDot(n,d);
	if (sub_alpha==0.0f)
		return;
	float	alpha = dvDot(n,dif)/sub_alpha;
	dvCross(n,d0,n0);
	dvCross(n,d1,n1);
	dvMad(b,d,alpha,cross_point);
	dvSub(cross_point,v0.position,dif);
	float	beta = dvDot(n0,dif)/dvDot(n0,d1),
			gamma = dvDot(n1,dif)/dvDot(n1,d0);
	if (beta >= 0 && gamma >= 0 && beta+gamma <= 1 && alpha >= 0)
	{
		if (_atomicCAS(&intersection->isset, 0, 1))
		{
			intersection->vertex[0] = v0;
			intersection->vertex[1] = v1;
			intersection->vertex[2] = v2;
			intersection->fc[0] = gamma;
			intersection->fc[1] = beta;
			intersection->fc[2] = alpha;
		}
	}