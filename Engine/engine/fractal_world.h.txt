#ifndef engine_fractal_worldH
#define engine_fractal_worldH

#include "../structure/fractal_map.h"
#include "../structure/cgs.h"
#include "aspect.h"

/******************************************************************

E:\include\engine\fractal_world.h

This file is part of Delta-Works
Copyright (C) 2006-2008 Stefan Elsen, University of Trier, Germany.
http://www.delta-works.org/forge/
http://informatik.uni-trier.de/

******************************************************************/

namespace Fractal
{
	using namespace Engine;
	
	static const tHeight		earth_radius = 6372795.47;
	
	/*channel configuration:
	
	
	channel0: height overlay 0
	channel1: height overlay 1
	channel2: soil_richness
	channel3: groundwater
	
	equation:
	
		general distribution: (p0+p1)/2 + (p0-p1)/2*distance*random(-1,1)
		
		
		height: overlay0*overlay1
		fertility = soil*groundwater
		
	
	*/

	class CNativeKernel
	{
		tHeight					init(tChannelValue*vertex, CRandom&random);
		void					generate(const tChannelValue*p0, const tChannelValue*p1, tChannelValue*result, float distance, CRandom&random, const CAbstractFace*context);
		tHeight					merge(const tChannelValue*p0,const tChannelValue*p1,const tChannelValue*s0,const tChannelValue*s1,const tChannelValue*s2,const tChannelValue*s3,tChannelValue*vertex, const CAbstractFace*context);

		eCastResult				cast(CAbstractFace*face);
		void					defineSphere(CAbstractFace*sector,CAbstractSphere<float>&target);
		void					update(CAbstractFace*face);
	};
	

	
	struct TAspect
	{
		CAspect<float>			general_aspect;
		CVec3<int>					sector;
	};

	template <typename T>
		struct TRange
		{
			T						min, max;
			
									TRange():min(0), max(1)
									{}
									
									TRange(const T& exact):min(exact),max(exact)
									{}
									
									TRange(const T& min_, const T& max_):min(min_),max(max_)
									{}
		};
		
	template <typename T>
		struct TOptimum
		{
			T						optimum, tolerance;
			
									TOptimum():optimum(0), tolerance(1)
									{}
									
									TOptimum(const T& exact):optimum(exact),tolerance(1)
									{}
									
									TOptimum(const T& optimum_, const T& tolerance_):optimum(optimum_),tolerance(tolerance_)
									{}
		};		
	
	typedef TRange<tHeight>			THeightRange;
	typedef TRange<tChannelValue>	TChannelRange;
	
	struct TConfiguration
	{
			tHeight					height_variation,
									water_height;
			
			tChannelValue			fertility_average,
									fertility_variation,
									atmospheric_density;
			
			bool					has_water;
			
			CString					primary_seed;
	};
	
	class CConfigurationTemplate
	{
	public:
			THeightRange			height_variation,	//relative to height_average+sphere_radius
									water_height;
									
			TChannelRange			fertility_average,	//fertility clamped to [0-1]
									fertility_variation,
									atmospheric_density;
			
			float					water_probability;
			
									CConfigurationTemplate();
			
			TConfiguration			generateConfiguration(const CString&seed)	const;
			TConfiguration			generateConfiguration()						const;
	};
	
	/*abstract*/ class CObjectClass;
	
	/*abstract*/ class CObject
	{
	public:
			CObjectClass							*const	parent_class;	//!< Parent class (must not be NULL)
			CGS::CGeometryInstance<CGS::CStdDef>	*const	instance;		//!< Geometrical instance (may be NULL implying explicit rendering)
						
									CObject(CObjectClass*class_,CGS::CGeometryInstance<CGS::CStdDef>*instance_):parent_class(class_),instance(instance_)	{}
	virtual							~CObject()	{};
	virtual	void					render()=0;
	
	};
	
	/*abstract*/ class CObjectClass
	{
	public:
			const TOptimum<float>			vertex_radius;
			const TOptimum<tHeight>			height;
			const TOptimum<tChannelValue>	fertility;
			const CString					name;
			const bool						vertex_object,
											scenery_object;
			
									CObjectClass(	const TOptimum<float>			&vertex_radius_,
													const TOptimum<tHeight>			&height_,
													const TOptimum<tChannelValue>	&fertility_,
													bool vertex_object_,
													bool scenery_object_):vertex_radius(vertex_radius_),height(height_),fertility(fertility_),vertex_object(vertex_object_),scenery_object(scenery_object_) {}
	virtual							~CObjectClass();
	virtual	CObject*				createInstance(const CString&seed);
			float					getProbability(float vradius, const tHeight&height, const tChannelValue&fertility);
	};
	
	
	class CObjectClassContainer:public CReferenceVector<CObjectClass>
	{
	public:
			CObject*				createInstance(float vradius, const tHeight&height, const tChannelValue&fertility);
	};
	
	
	
	
	extern THeightRange				default_height_average,
									default_height_variation,
									default_water_height;
	extern TChannelRange			default_ferility_average,
									default_ferility_variation;
	extern float					default_water_probability;

	template <class GL, unsigned Exponent>
		class CAttachment
		{
		public:
				typename GL::VertexObject	vbo;
				typename GL::IndexObject	ibo;
				TConfiguration				configuration;
				bool						reload;
				
				
											CAttachment();
		};

	template <class GL, class Kernel=CNativeKernel, unsigned Exponent=5>
		class CWorld:public CConstruct<Exponent,4,CAttachment<GL,Exponent> >
		{
		private:
				TConfiguration				config;
		public:
											CWorld();
				
				void						configure(const TConfiguration&configuration);
				void						remake(const CGeometry&geometry, const TForm&form);
		};

};





#endif
