/*
	generate4() function content for inclusion in cuda kernel and cpu adaptions
	void		generate4(const TVertex&p0, const TVertex&p1, const TVertex&p2, const TVertex&p3, TVertex&result, int seed, T(Host/Device)Surface&surface, const TContext&context)
*/



	float distance = dvDistance(p0.position,p1.position);	
	
	float noise = getNoise(distance,p0,p1,surface,context);

	float weight= SECONDARY_PARENT_WEIGHT;

	int random_seed = seed;

	#if SELECTIVE_WEIGHTING
	{
		float	close_delta = fabsf((float)(p0.FRACTAL_HEIGHT-p1.FRACTAL_HEIGHT)),
				far_delta = fabsf((float)(p2.FRACTAL_HEIGHT-p3.FRACTAL_HEIGHT)),
				sum = (close_delta+far_delta)+0.001,
				balance = dbSqr(dbClamped(close_delta/sum,0.2f,0.9f));
		
		weight *= (1.0-balance);
	}
	#endif

	#if WEIGHTING==TWO_PARENTS_BALANCED
		float	w2 = 0,
				w3 = 0,
				w0 = 0.5,
				w1 = 0.5;
	#elif WEIGHTING==TWO_PARENTS_AGE_SENSITIVE
		float	total_age = p0.channel.age+p1.channel.age,
				w2 = 0,
				w3 = 0,
				w0 = p0.channel.age/total_age,
				w1 = p1.channel.age/total_age;
	#elif WEIGHTING==SIMPLE_BALANCED
		float	w2 = 0.19098300563f,
				w3 = 0.19098300563f,
				w0 = 0.30901699437f,
				w1 = 0.30901699437f;
	#elif WEIGHTING==HALF_AGE_SENSITIVE
		float	total_age = p2.channel.age+p3.channel.age,
				w2 = weight*p2.channel.age/total_age*0.5f,
				w3 = weight*p3.channel.age/total_age*0.5f,
				w0 = 0.5-(w2+w3)/2.0,
				w1 = 0.5-(w2+w3)/2.0;
	#elif WEIGHTING==FULL_AGE_SENSITIVE
		float	total_age = p0.channel.age+p1.channel.age+p2.channel.age*weight+p3.channel.age*weight,
				w2 = weight*p2.channel.age/total_age,
				w3 = weight*p3.channel.age/total_age,
	 			w0 = p0.channel.age/total_age,
				w1 = p1.channel.age/total_age;
	#elif WEIGHTING==SELECTIVE_AGE_SENSITIVE
		float	total_age = p0.channel.age+p1.channel.age+p2.channel.age*weight+p3.channel.age*weight,
				w2 = weight*p2.channel.age/total_age,
				w3 = weight*p3.channel.age/total_age,
	 			w0 = p0.channel.age/total_age,
				w1 = p1.channel.age/total_age;
		if (w0 > 0.3f)
		{
			w0 = 1.0f;
			w1 = 0.0f;
			w2 = 0.0f;
			w3 = 0.0f;
		}
		elif (w1 > 0.3f)
		{
			w1 = 1.0f;
			w0 = 0.0f;
			w2 = 0.0f;
			w3 = 0.0f;
		}
		elif (w2 > 0.3f)
		{
			w2 = 1.0f;
			w0 = 0.0f;
			w1 = 0.0f;
			w3 = 0.0f;
		}
		elif (w3 > 0.3f)
		{
			w3 = 1.0f;
			w0 = 0.0f;
			w1 = 0.0f;
			w2 = 0.0f;
		}
		else
		{
			w2 = 0.19098300563f;
			w3 = 0.19098300563f;
			w0 = 0.30901699437f;
			w1 = 0.30901699437f;
		}
	#elif WEIGHTING==BALANCED_AGE_SENSITIVE
		float	total_age = p0.channel.age+p1.channel.age+p2.channel.age*weight+p3.channel.age*weight,
				w2 = weight*p2.channel.age/total_age,
				w3 = weight*p3.channel.age/total_age,
	 			w0 = (p0.channel.age+p1.channel.age)/total_age/2.0f,
				w1 = w0;
	#else
		float	w2 = weight*0.25f,
				w3 = weight*0.25f,
				w0 = 0.5-(w2+w3)/2.0,
				w1 = 0.5-(w2+w3)/2.0;
	#endif
			
	result.channel.c0 = dbClamped((w0*p0.channel.c0+w1*p1.channel.c0+w2*p2.channel.c0+w3*p3.channel.c0)+noise*getRandom(random_seed) C0_CUSTOM_NOISE_FACTOR,0,1);
	result.channel.c1 = dbClamped((w0*p0.channel.c1+w1*p1.channel.c1+w2*p2.channel.c1+w3*p3.channel.c1)+noise*getRandom(random_seed) C1_CUSTOM_NOISE_FACTOR,0,1);
	result.channel.c2 = w0*p0.channel.c2+w1*p1.channel.c2+w2*p2.channel.c2+w3*p3.channel.c2;
	#if FRACTAL_KERNEL!=MINIMAL_KERNEL
		result.channel.c3 = dbClamped((w0*p0.channel.c3+w1*p1.channel.c3+w2*p2.channel.c3+w3*p3.channel.c3)+noise*getRandom(random_seed) C3_CUSTOM_NOISE_FACTOR,0,1);
	#endif
	#if FRACTAL_KERNEL==FULL_KERNEL
		result.channel.c4 = dbClamped((w0*p0.channel.c4+w1*p1.channel.c4+w2*p2.channel.c4+w3*p3.channel.c4)+noise*getRandom(random_seed) C4_CUSTOM_NOISE_FACTOR,0,1);
	#endif
	
	float	riff_distance = fabsf(0.5f-result.channel.c2)*5.0f,
			riff_noise = noise*getRandom(random_seed) C2_CUSTOM_NOISE_FACTOR;

	if (riff_distance>=0.02 && riff_distance < 0.13)
	#if FRACTAL_KERNEL==FULL_KERNEL
		riff_noise/=(1.0f+result.channel.c4*result.channel.c3);
	#elif FRACTAL_KERNEL!=MINIMAL_KERNEL
		riff_noise/=(1.0f+0.25*result.channel.c3);
	#else
		riff_noise/=(1.0f+0.25);
	#endif
	#if FRACTAL_KERNEL==MINIMAL_KERNEL
		riff_noise *= 0.5;
	#endif
	
	
	result.channel.c2 = dbClamped(result.channel.c2+riff_noise,0,1);

	result.channel.oceanic = dbClamped((w0*p0.channel.oceanic+w1*p1.channel.oceanic+w2*p2.channel.oceanic+w3*p3.channel.oceanic)+noise*getRandom(random_seed)*CONTINENTAL_NOISE,0,1);

	//result.channel.age = ageAt(surface.depth);

	
	
	result.channel.water = 0;//(w0*p0.channel.water+w1*p1.channel.water+w2*p2.channel.water+w3*p3.channel.water);
	
	
	/*{
		// smooth channels: doesn't work
		
		float smooth_strength = getSmoothStrength(distance,p0,p1,surface,context);
		
		float	w2 = 0.25f,
				w3 = 0.25f,
				w0 = 0.25f,
				w1 = 0.25f;
		
		result.channel.c0 = (1.0f-smooth_strength)*result.channel.c0+(smooth_strength*(p0.channel.c0*w0+p1.channel.c0*w1+p2.channel.c0*w2+p3.channel.c0*w3));
		result.channel.c1 = (1.0f-smooth_strength)*result.channel.c1+(smooth_strength*(p0.channel.c1*w0+p1.channel.c1*w1+p2.channel.c1*w2+p3.channel.c1*w3));
		result.channel.c2 = (1.0f-smooth_strength)*result.channel.c2+(smooth_strength*(p0.channel.c2*w0+p1.channel.c2*w1+p2.channel.c2*w2+p3.channel.c2*w3));
		#if FRACTAL_KERNEL!=MINIMAL_KERNEL
			result.channel.c3 = (1.0f-smooth_strength)*result.channel.c3+(smooth_strength*(p0.channel.c3*w0+p1.channel.c3*w1+p2.channel.c3*w2+p3.channel.c3*w3));
		#endif
		#if FRACTAL_KERNEL==FULL_KERNEL
			result.channel.c4 = (1.0f-smooth_strength)*result.channel.c4+(smooth_strength*(p0.channel.c4*w0+p1.channel.c4*w1+p2.channel.c4*w2+p3.channel.c4*w3));
		#endif		
	}*/
	
	#ifdef RIVERS
		float mid = p0.channel.river_depth*0.5f+p1.channel.river_depth*0.5f;
		result.channel.river_depth = dbClamped( mid*0.5f+ 0.5f*(p0.channel.river_depth*w0 + p1.channel.river_depth*w1 + p2.channel.river_depth*w2 + p3.channel.river_depth*w3)-fabsf(noise*10.0f*getRandom(random_seed)),0,1);
		//result.channel.river_depth = p0.channel.river_depth*0.5f+p1.channel.river_depth*0.5f;
		//fminf((p0.channel.river_depth*w0 + p1.channel.river_depth*w1 + p2.channel.river_depth*w2 + p3.channel.river_depth*w3),1.0f);
		
		/*if (surface.depth == context.recursive_depth-4 && getRandom(random_seed) < -0.9)
			result.channel.river_depth = 0.75f;*/
				
	#endif
	
	
	result.FRACTAL_HEIGHT = height(result.channel);
	

	
	{	//remove spikes
	
		//result.channel.age = 1.0f;
		
		float avg = (p0.FRACTAL_HEIGHT+p1.FRACTAL_HEIGHT+p2.FRACTAL_HEIGHT+p3.FRACTAL_HEIGHT)/4.0f;
		float rng = fmaxf
					(
						fmaxf
						(
							fmaxf
							(
								fabsf(p0.FRACTAL_HEIGHT-avg),
								fabsf(p1.FRACTAL_HEIGHT-avg)
							),
							fmaxf
							(
								fabsf(p2.FRACTAL_HEIGHT-avg),
								fabsf(p3.FRACTAL_HEIGHT-avg)
							)
						)
						,0.001f
					);//0.75f;
		float depth = (float)surface.depth/context.recursive_depth;
		result.channel.age = getWeight(result.FRACTAL_HEIGHT,avg,rng,depth);
		
		

		/* doesn't work
		const TVertex*max=&p0,*min=&p0;
		if (max->height < p1.height)
			max = &p1;
		if (max->height < p2.height)
			max = &p2;
		if (max->height < p3.height)
			max = &p3;
			
		if (min->height > p1.height)
			min = &p1;
		if (min->height > p2.height)
			min = &p2;
		if (min->height > p3.height)
			min = &p3;
		
		if (result.height < min->height)
		{
			result.channel = min->channel;
			result.height = min->height;
		}
		elif (result.height > max->height)
		{
			result.channel = max->channel;
			result.height = max->height;
		}*/

	
	
		/* doesn't work
		float	min = fminf(fminf(p0.height,p1.height),fminf(p2.height,p3.height)),
				max = fmaxf(fmaxf(p0.height,p1.height),fmaxf(p2.height,p3.height)),
				avg = (min+max)/2.0f,
				rng = (max-min)/2.0f;
		
		result.height = dbClamped(result.height,avg-rng,avg+rng);
		*/
	}
	
		//result.channel.water = 0;
		if (p0.FRACTAL_HEIGHT > result.FRACTAL_HEIGHT)
			result.channel.water += p0.channel.water*WATER_GAIN_DOWN*w0;
		else
			result.channel.water += p0.channel.water*WATER_GAIN_UP*w0;
		if (p1.FRACTAL_HEIGHT > result.FRACTAL_HEIGHT)
			result.channel.water += p1.channel.water*WATER_GAIN_DOWN*w1;
		else
			result.channel.water += p1.channel.water*WATER_GAIN_UP*w1;
		if (p2.FRACTAL_HEIGHT > result.FRACTAL_HEIGHT)
			result.channel.water += p2.channel.water*WATER_GAIN_DOWN*w2;
		else
			result.channel.water += p2.channel.water*WATER_GAIN_UP*w2;
		if (p3.FRACTAL_HEIGHT > result.FRACTAL_HEIGHT)
			result.channel.water += p3.channel.water*WATER_GAIN_DOWN*w3;
		else
			result.channel.water += p3.channel.water*WATER_GAIN_UP*w3;
		
		if (result.FRACTAL_HEIGHT < -0.005)
			result.channel.water += 0.1;
		result.channel.water = dbClamped(result.channel.water+noise*getRandom(random_seed)*WATER_NOISE,0.0f,context.fertility);

