#ifndef physicsH
#define physicsH

//#include "../structure/fractal_map.h"
//#include "../fractal/fractal.h"
#include "../geometry/cgs.h"
#include "../al/openal.h"
#include "../general/timer.h"
//#include "../engine/aspect.h"
#include "../math/vclasses.h"
#include "../io/xml.h"
#include "../io/file_system.h"
#include "../geometry/cgs_track_segment.h"


#ifndef _M_X64
	#pragma comment(lib,"PhysXLoader.lib")
	#pragma comment(lib,"PhysXCore.lib")
#else
	#pragma comment(lib,"PhysXLoader64.lib")
	#pragma comment(lib,"PhysXCore64.lib")
#endif

class NxPMap;

#include <NxPhysics.h>
#include <NxWheelShapeDesc.h>
#include <NxWheelShape.h>
#include <NxUserContactReport.h>
#include "nx_buffers.h"
#include "nx_cooking.h"
#include "nx_math.h"
#include "../general/auto.h"
//#include "../general/managed.h"

//#include "planet.h"


/*
	Notes:
	
		player rotation efficiency: sin(PI/(speed/optimal_speed+1))*optimal_maneuverability*pressure*dot(direction,inertia)
		ship rotation efficiency (speed at which ship rotates to wind):sin(PI/(speed/optimal_speed+1))*optimal_maneuverability*pressure*(1-dot(direction,inertia))
	


*/


/**
	@brief PhysX driven physical simulation supporting large scale fractal landscapes
*/
namespace Physics
{

	typedef CGS::SubGeometryA<>::PhDef	PhDef;
	typedef CGS::StdDef::PhFloatType	PhFloat;
	typedef CGS::StdDef::SystemType	SysFloat;
	

	struct TBody;
	class AbstractGround;
	
	namespace ActorGroup
	{
		enum group_t
		{
			StaticMesh,
			DynamicMesh,
			Wheel
		};
	}
	
	typedef ActorGroup::group_t	group_t;
	
	/**
		@brief Simulation environment definition
		
		Most operations performed by this unit require the specification of an environment structure. This structure defines outlining attributes of the world that surrounds the simulation.
	
	*/
	struct TEnvironment
	{
			/**
				@brief Callback function to determine the atmospheric density at a given point
				@param position Point to retrieve the atmospheric density for
				@return Atmosphere density in bar (>=0)
			*/
			float			(*getAtmosphereDensity)(const Composite::Coordinates&position);
			/**
				@brief Callback function to retrieve the gravitational acceleration vector at a given point
				@param position Point to retrieve the gravity vector for
				@param vector [out] Out vector to write the resulting gravity vector to
			*/
			void			(*getGravityAcceleration)(const Composite::Coordinates&position,float3&vector);
			
			/**
				@brief Environment scale
				
				The content of this variable represents the distance of one meter in the governing environment
			*/
			float			system_unit_size;
			
			/**
				@brief Coordinate sector size
				
				Sector relative coordinates are always less than this value.
			*/
			float			sector_size;
			/**
				@brief Reference to the used PhysX scene. This value should be initialized with the result of init()
			*/
			Auto<NxScene*>	scene;
	};


	struct TContact
	{
			Composite::Coordinates		coordinates;
			float						age,
										intensity;
	};



	/**
		@brief Vehicular emission types generated by an active drive
	*/
	enum EmissionType
	{
		Noise,	//!< Accustic emission. This intensifies with increasing atmosphere densities
		Heat,	//!< Heat emission. Slighly affected by atmosphere density
		EM,		//!< Electro magnetic emission. Not affected by atmosphere density
		Light,	//!< Photon emission. Damped by atmosphere density
		Exhaust,	//!< Gas emission. Not affected by atmosphere density
		
		EmissionTypes	//!< Number of supported emission types
	};
	
	
	
	class Vehicle;

	extern Queue<TContact>		contacts;
	extern Mutex				contact_mutex;
		
	
	/**
		One time sound instance. Plays exactly once, then erased.
	*/
	class SoundInstance:public OpenAL::Source
	{
	public:
			Composite::Coordinates	coordinates;	//!< Composite of this instance (fixed)
			bool					started;		//!< True if the sound has been started
	static	OpenAL::Wave			impact_sound,	//!< Global ground impact sound resource
									splash_sound;	//!< Global water impact sound resource
	
									SoundInstance(){}
									SoundInstance(const Composite::Coordinates&coordinates, float system_unit_size, float intensity, const OpenAL::Wave&wave,bool alter_pitch);

			void					swap(SoundInstance&other)
									{
										swp(coordinates,other.coordinates);
										swp(started,other.started);
										OpenAL::Source::swap(other);
									}
	};
	

	/**
		Pure abstract physical entity in a simulated environment
	*/
	class Entity
	{
	public:
			//status:
			Composite::Coordinates	coordinates;		//!< Current space coordinates
			float3					y_axis,				//!< Entity y-vector (roughly orthogonal to z_axis)
									z_axis;				//!< Entity z-vector (roughly orthogonal to y_axis)
			bool					z_is_primary;		//!< Indicates whether the entity should primarily orientate to the z-axis or the y-axis. True by default
			
			//input:
			float					atmosphere_density;	//!< Atmosphere density surrounding this entity. Initially set to 1, not altered by the entity simulator
			
			union
			{
				struct
				{
					float			yaw,				//!< Yaw/horizontal rotation control [-1, +1]. 0 by default
									pitch,				//!< Pitch/vertical rotation control [-1, +1]. 0 by default
									roll;				//!< Roll/z-axis rotation control [-1, +1]. 0 by default
				};
				struct
				{
					float			rotate_horizonal,	//!< Yaw/horizontal rotation control [-1, +1]. 0 by default
									rotate_vertical,	//!< Pitch/vertical rotation control [-1, +1]. 0 by default
									rotate_z;			//!< Roll/z-axis rotation control [-1, +1]. 0 by default
				};
			};

			//output:
			TMatrix4<>				system,			//!< Orthogonal normalized outbound system as built from y_axis and z_axis. The offset vector is 0.since the system does not include the actual entity coordinates. The additional non used data in the system matrix is for interface convenience.
									invert;			//!< Invert of system: orthogonal normalized inbound system
			float					velocity;			//!< Current velocity
			float3					inertia,			//!< Entity inertia
									heading;			//!< Effective viewing direction
			//Planet*						closest_planet;		//!< Closest detected planet (if any)
			float					ground_age;					//!< Time in seconds since last ground detection
			bool					ground_detected;			//!< True if ground beneath the ship has been detected
			double					height_above_water,			//!< Last detected height above the closest planet's water surface
									ground_height_above_water,	//!< Height of the ground underneath this entity relative to the respective planet's water surface. Available only if @b ground_detected is true
									height_above_ground;		//!< Height above the ground underneath this entity. Available only if @b ground_detected is true
			float3					ground_position,		//!< Detected ground position in the sector of this entity
									ground_normal,			//!< Absolute ground normal
									up;						//!< Ground up vector
			
			
									Entity();
			void					updateSystem();
			bool					detectGround(const TEnvironment&env, float delta);
			void					reset();
	};
	
	/**
		@brief First person entity
	*/
	class FirstPerson: public Entity
	{
	public:
			float					height;	//!< Height that this entity stays above the ground
			float3					speed;	//!< Maximum speed in the respective direction
											
									FirstPerson():height(1)
									{
										z_is_primary = true;
									}
			void					process(const TEnvironment&env, float delta);
	};
	
	
	/**
		@brief Smoke particle, as produced by a jet engine
	*/
	struct TSmokeParticle
	{
		float3	position,	//!< Particle position
				up,
				right,
				velocity;
		float	intensity,
				age;
	};





	class EngineType;
	
	
	class Prototype	//! (non-simulated) prototype
	{
	public:
			const CGS::SubGeometryA<>			*system;		//!< Parent sub geometry
			EngineType							*engine_type;	//!< Engine specification
			
												Prototype():system(NULL),engine_type(NULL)
												{}
	};

	
	class WheelPrototype:public Prototype, public NxUserWheelContactModify	//! (non-simulated) wheel prototype
	{
	public:
			CGS::TWheel<>						*wheel;			//!< Attached wheel structure
			Array<index_t>						path;						//!< Index path to this wheel
			NxMaterial							*material;	//apparently managed by Nx
			NxWheelShapeDesc					desc;

												WheelPrototype():wheel(NULL),material(NULL)
												{}
			void								configure(const TEnvironment&env, CGS::Geometry<>&geometry);
	virtual bool 								onWheelContact(NxWheelShape* wheelShape, NxVec3& contactPoint,
																NxVec3& contactNormal, NxReal& contactPosition,
																NxReal& normalForce, NxShape* otherShape,
																NxMaterialIndex& otherShapeMaterialIndex,
																NxU32 otherShapeFeatureIndex);
	};
	

	class FlamePrototype:public Prototype	//! (non-simulated) flame prototype
	{
	public:
			CGS::TAccelerator<>					*accel;			//!< Attached accelerator
			
			
												FlamePrototype():accel(NULL)
												{}
	};
	
	class Flame	//! Instantiated flame
	{
	public:
			const TMatrix4<SysFloat>			*system;	//!< Absolute flame-to-world system
			CGS::TAccelerator<>					*accel;		//!< Accelerator specification
			typedef Queue<TSmokeParticle>		DQueue;
			DQueue								trail;			//!> Trail queue
			OpenAL::Source						sound_source;	//!< Engine sound player
			
												Flame():system(NULL),accel(NULL)
												{}
			void								init(FlamePrototype*prototype);	//!< Inits this flame from an existing flame prototype
	};
	
	
	/*
	struct TBody
	{
			CGS::StdDef::SystemType		*system;
			Mesh<PhDef>					*hull;
			Vehicle						*vehicle;
	};
	
	struct TVertex
	{
			MeshVertex<PhDef>				*target;
			CGS::StdDef::PhFloatType		position[3],
											normal[3];
			Vehicle						*vehicle;
	};
	
	struct TTriangle
	{
			MeshTriangle<PhDef>				*target;
			unsigned						vertex[3];
			CGS::StdDef::PhFloatType		normal[3];
			Vehicle						*vehicle;
	};
	
	struct TQuad
	{
			MeshQuad<PhDef>					*target;
			unsigned						vertex[4];
			CGS::StdDef::PhFloatType		normal[3];
			Vehicle						*vehicle;
	};
	
	struct TEdge
	{
			MeshEdge<PhDef>					*target;
			unsigned						vertex[2];
			Vehicle						*vehicle;
	};*/
	
	
	class Wheel	//! Instantiated wheel
	{
	protected:
			//void 								processTriangle(PhFloat grip, Vehicle*vehicle, const PhFloat normal[3], unsigned v0, unsigned v1, unsigned v2);
			void								paintTrail(const float3&contact_point, const NxVec3&contact_normal);
			void								closeTrail();
	public:
			struct TTrailPoint	//! Singular trail point. Always part of a trail
			{
				Composite::Coordinates			position;	//!< I know this is a bit of overkill but unfortunately i see no way of kicking that sector offset out of here :(
				float3							normal;		//!< Contact normal
				float							intensity;	//!< Grinding intensity
			};
			
			struct TTrail	//! Disjunct trail. Sequence of TTrailPoint's
			{
				float							first_age,	//!< Age of the first created trail point
												last_age;	//!< Age of the last created trail point
				
				unsigned						display_list;	//!< For custom rendering. Initialized with 0
				Buffer<TTrailPoint>				points;			//!< Trail points of this trail
			
												
												TTrail():display_list(0),points(0)
												{}
			};
			
			Queue<TTrail>						trails;		//!< Trails of this wheel
			TTrail								*active_trail;	//!< Trail that elements are currently appended to
	
			const TMatrix4<SysFloat>			*system;	//!< Absolute wheel-to-world system
			
			CGS::TWheel<>						*wheel;						//!< Pointer to the base wheel configuration
			OpenAL::Source						sound_source;				//!< Tire squealing sound player
			bool								sound_muted;
			TMatrix4<>							inner_system;				//!< Wheel system, calculated from wheel axis and contraction with the wheel axis pointing along the positive x axis and contraction roughly along the positive y axis. The system center resides in the relative uncontracted wheel location
			PhFloat								contraction_length,			//!< Absolute length of the wheel contraction vector
												
												xgrip,						//!< Current transversal ground grip
												grinding,					//!< Current wheel grinding (causing noise and skidmark)
												smoothed_grinding,			//!< A less volatile value of grinding, smoothed over the last 0.1 seconds
												inertia;					//!< Wheel rotation inertia
			Composite::Coordinates				last_position;				//!< Last absolute wheel location
			double								*wheel_status;				//!< Reference to the animation status vector. The first entry features acceleration, the second one braking
			CGS::AnimatorInstanceA<>			*rotation,					//!< Rotation animation of this wheel (if any)
												*suspension;				//!< Suspension animation of this wheel (if any)
			Auto<NxWheelShape*>					shape;						//!< PhysX shape reference
			Auto<bool>							has_contact,				//!< True if this wheel has contact to the ground (or another structure)
												was_accelerated;			//!< True if this wheel has ever been accelerated
	
	static	float								trail_max_age;
	static	void 								(*onTrailExpand)(Wheel*wheel, TTrail&trail);	//!< Invoked if an existing trail has been expanded by a trail point
	static	void								(*onTrailFinish)(Wheel*wheel, TTrail&trail);	//!< Invoked if a trail has been finished and a new one has been started
	static	void								(*onTrailDelete)(Wheel*wheel, TTrail&trail);	//!< Invoked if a trail is about to be deleted out of old age
	static	OpenAL::Wave						tire_scream;	//!< Tire scream sound
	
	/*
	static	Buffer<TTriangle>					triangles;
	static	Buffer<TQuad>						quads;
	static	Buffer<TVertex>					collidable_vertices,	//!< Vertices considered for collisions
												all_vertices;
	static	Buffer<TEdge>						edges;
	static	Buffer<TBody>						bodies;
	static	Buffer<AbstractGround*>			grounds;
	static	Buffer<TContact>					contacts;
	*/
												

												Wheel():active_trail(NULL),system(NULL),wheel(NULL),contraction_length(1),
														xgrip(0),grinding(0),smoothed_grinding(0),inertia(0),
														wheel_status(NULL),rotation(NULL),suspension(NULL),
														shape(NULL)
												{}
			void								init(WheelPrototype*prototype);	//!< Inits this wheel from an existing wheel prototype
			void 								process(const TEnvironment&env, float delta, Vehicle*vehicle, float motor_efficiency);
			void								updateInnerSystem();	//!< Updates the inner_system matrix based on the current configuration of the linked wheel
			void								reset();
	};
	
	/**
		@brief Vehicular engine type
		
	*/
	class EngineType
	{
	public:
			String							name;						//!< Engine type name
	
			float							base_acceleration;			//!< Basic engine acceleration in m/s²
			float2							optimal_pressure_window,	//!< minimal/maximum pressure for optimal engine performance
											minimal_pressure_window,	//!< minimal/maximum pressure for any engine performance. The engine will work at 50% at any of these extremes
											zero_efficiency_window;	//!< Automatically applied to accelerators with a zero efficiency in this window
			float3							flame_color;				//!< Effective flame color
			float							heat_up,					//!< Time in seconds the drive needs to heat up. During this time the drive requires 100% fuel/energy, operates at half flame size and signature and 10% efficiency. Heat up is required whenever the drive was switched off.
											energy_consumption,			//!< Base energy consumption per second
											fuel_consumption,			//!< Base fuel consumption per second
											signature[EmissionTypes],	//!< Maximum drive emission
											exponent[EmissionTypes];	//!< Signature exponent applied to the current status before multiplying it with the respective @b signature value
			
			OpenAL::Wave					sound;						//!< Engine sound

											EngineType():base_acceleration(1),energy_consumption(1),fuel_consumption(1)
											{
												Vec::def(optimal_pressure_window,0,1);
												Vec::def(minimal_pressure_window,0,10000000);
												Vec::def(zero_efficiency_window,0,10000000);
												Vec::def(flame_color,1,0.5,0);
												VecUnroll<EmissionTypes>::set(signature,0.5f);
												VecUnroll<EmissionTypes>::set(exponent,2.0f);
											}
			template <typename T0, typename T1>
				static inline bool isIn(T0 value, const TVec2<T1>&window)
				{
					return value >= window.x && value <= window.y;
				}

			/**
				@brief Determines the efficiency of this drive at the specified atmospheric density
			*/
			float							efficiency(float density)	const
											{
												if (!isIn(density,minimal_pressure_window))
													return 0;
												if (isIn(density,optimal_pressure_window))
													return 1;
												if (density < optimal_pressure_window[0])
													return cosStep(density,minimal_pressure_window[0],optimal_pressure_window[0]);
												return 1.0f-cosStep(density,optimal_pressure_window[1],minimal_pressure_window[1]);
											}
	};
	
	
	

	class EnginePrototype	//! Flame prototype container
	{
	public:
			EngineType						*type;
			float							support;	//!< Vehicular support for this engine type. This value effectivly scales the thrust output of this engine.
			
			Buffer<FlamePrototype,0>		flames;		//!< Flames associated with this engine
			void							adoptData(EnginePrototype&other)
											{
												type = other.type;
												support = other.support;
												flames.adoptData(other.flames);
											}
	};

	
	/**
		@brief Engine describes a family of drives mounted to a ship.
	*/
	class Engine
	{
	public:
			EngineType						*type;						//!< Engine type specification
											
			float							support,					//!< Percentual support for the requested engine type
											heat_up_remaining,			//!< Remaining seconds until drive is fully operational. 0 means drive is ready
											status,						//!< Current drive status (ranging 0 to 1). The engine switches off if @b status is less than 0.1 (10%). Status affects the effective power, fuel/energy consumption and flame size
											flame_size,					//!< Current flame size
											acceleration,				//!< Current acceleration (ranging 0 to 1 - not yet multiplied by base acceleration)
											fuel_consumption,			//!< Current fuel_consumption
											energy_consumption,			//!< Current energy_consumption
											signature_level;			//!< Base signature level
			Array<Flame>					flames;						//!< Collection of all intantiated flames
			
			void							init(EnginePrototype*prototype);	//!< Intiates this engine from the specified engine prototype
	};
	
	/**
		@brief General vehicle configuration
	*/
	struct TVehicleConfig
	{
			float							radius,						//!< Ship radius (from its center)
											mass;						//!< Vehicle mass
			float3							friction,					//!< Directional ship friction
											rotation_friction;			//!< Rotation friction along the specified axis
			
			//ship attributes:
			float							optimal_speed,				//!< Speed at which the ship reaches optimal maneuverability
											optimal_maneuverability,	//!< General maneuverability at optimal speed under atmospheric conditions
											zero_maneuverability,		//!< General maneuverability at very low atmosphere densities regardless of speed
											updrift;					//!< Updrift force relative to atmosphere pressure and movement speed
			float3							rotation_speed;				//!< Rotation speed
			
			//car attributes:
			float							brake_strength,				//!< Effective brake strength
											center_height;				//!< Relative center of gravity height (0=vehicle bottom, 1=vehicle top)
			float							forward_down_drift,	//!< Factor to apply to vertical force derived from forward movement
											backward_down_drift,//!< Factor to apply to vertical force derived from backward movement
											transveral_down_drift;	//!< Factor to apply to vertical force derived from sideward movement

	};
	
	/**
		@brief Prototype used to describe a vehicle
		
		A single prototype may be used to generated multiple vehicles. All vehicles must be generated from some prototype.
	*/
	class VehiclePrototype
	{
	protected:
			Buffer<index_t>					path;	//!< Temporal CGS object path
			
			void 							scanItemsRec(const TEnvironment&env, CGS::SubGeometryA<>&geometry);	//!< Scans for wheels and accelerators recursivly
			void							loadFromXML(const XML::Container&container);
	public:
			enum Rotation	//! Rotation type
			{
				Pitch,			//!< Rotation about the x-axis (up/down)
				Yaw,			//!< Rotation about the y-axis (left/right)
				Roll			//!< Rotation about the z-axis (roll left/right)
			};
			
			enum Direction	//! Direction type
			{
				Horizontal,		//!< X-direction
				Vertical,		//!< Y-direction
				Directional		//!< Z-direction
			};
		
			CGS::Geometry<>					geometry;			//!< Vehicle geometry. Scaled by env.system_unit_size
			Buffer<EnginePrototype,0,Adopt>	engine_prototypes;	//!< Collection of engine prototypes
			TVehicleConfig					config;				//!< Physical configuration. Radius scaled by env.system_unit_size
			float3							center_of_gravity;	//!< Center of gravity. @b Not scaled by env.system_unit_size
			Buffer<WheelPrototype,0>		wheels;				//!< Wheels associated with this vehicle
			EnginePrototype					wheel_drive;		//!< Wheel drive prototype
			TBox<>							dimensions;			//!< Vehicle dimensions
			
			NxBodyDesc						body_desc;			//!< General body description. @b Not scaled by env.system_unit_size
			NxActorDesc 					actor_desc;			//!< Nx description of this vehicle @b Not scaled by env.system_unit_size
			NxConvexShapeDesc				hull_desc;			//!< Nx convex hull description of the non-animated vehicle hull @b Not scaled by env.system_unit_size
			//				hull_desc;
			//NxTriangleMeshShapeDesc			hull_desc;
	static	NxMaterial						*hull_material;		//!< Generated hull material. All vehicle prototypes share the same hull material (at this point)
			
											VehiclePrototype();
			bool							loadFromFile(const TEnvironment&env, const String&filename);	//!< Replaces all local data with the content of the specified file. @param env Environment configuration to use for the loading operation @param filename CGS file path to load from @return true on success, false otherwise
	};
	
	class StructureDescriptor
	{
	public:
			//
			NxBodyDesc						body_desc;	//!< PhysX body description
			NxActorDesc 					actor_desc;	//!< PhysX actor description
			Array<NxTriangleMeshShapeDesc>	hull_desc;			//!< PhysX mesh description
	static	NxMaterial						*hull_material[2];	//!< Static hull materials for static (0) and dynamic (1) structures
			TEnvironment					env;				//!< Environment description
	
	virtual									~StructureDescriptor();
			void							updateFromGeometry(const CGS::Geometry<>&, bool dynamic);
			void							updateFromHull(const Mesh<CGS::SubGeometryA<>::PhDef>&hull, bool dynamic);
			void							adoptData(StructureDescriptor&other)
											{
												body_desc = other.body_desc;
												actor_desc = other.actor_desc;
												hull_desc.adoptData(other.hull_desc);
												env = other.env;
											}

	};

	/**
		@brief Physical mesh  prototype
		
		Prototypes can be either for inanimate or dynamic structures
	*/
	class StructurePrototype:public StructureDescriptor
	{
	public:
			CGS::Geometry<>					geometry;	//!< Base geometry. Can be of any shape
			bool							loadFromFile(const TEnvironment&env, const String&filename, bool dynamic);	//!< Loads this prototype from a cgs file	@param env Environment definition structure @param filename CGS filename @param dynamic True if this object should be dynamic (moving). Otherwise the object will be collidable but remain inanimate @return true on success, false otherwise
			void							adopt(const TEnvironment&env, CGS::Geometry<>&geometry,bool dynamic);		//!< Adopts an already loaded cgs geometry	@param env Environment definition structure @param geometry CGS geometry (will be adopted, the passed geometry will be empty after this operation)  @param dynamic True if this object should be dynamic (moving). Otherwise the object will be collidable but remain inanimate
	};

	/**
		@brief Simulated structure
	
	*/
	class Structure:public Entity
	{
	public:
			StructureDescriptor*			descriptor;	//!< Used structure descriptor
			CGS::StaticInstance<>			instance;	//!< Simple sector-relative CGS instance
			Auto<NxActor*>					actor;		//!< PhysX actor
			
			const TEnvironment				*env;		//!< Simulation environment
			Auto<bool>						changed;	//!< Indicates that the PhysX actor pose (position&orientation) should be read from the entity configuration during the next process() call. Don't set this variable manually
			float3							sector_translation;	//!< Translation vector from the last relativation between the observer and the local entity
			
			
											Structure();
											Structure(StructurePrototype&prototype_);
	virtual									~Structure();
			void							process();	//!< Performs a number of per frame operations. Automatically called
			void							update();	//!< Signals that this entity has been moved directly (not due to the simulation) and should be relocated in the physical scenery

			Structure&						create(StructurePrototype&prototype_);

			void							adoptData(Structure&other)
											{
												((Entity&)*this) = (Entity&)other;
												descriptor = other.descriptor;
												instance.adoptData(other.instance);
												env = other.env;
												changed = other.changed;
												sector_translation = other.sector_translation;

												actor = other.actor;
												other.actor = NULL;
												other.changed = false;
											}
	};
	
	class UniqueStaticStructure:public StructureDescriptor
	{
	private:
			bool							installed;	//!< True if this segment has been installed (applied to the PhysX scenery
			bool							enqueued;


			void							removeFromQueue();
			void							enqueue(bool ignore_state);
	public:
			
			Composite::Coordinates			coordinates;
			TMatrix3<>						orientation;
			NxActor*						actor;		//!< Pointer to the instantiated PhysX actor
			float3							sector_translation;	//!< Translation vector from the last relativation

											UniqueStaticStructure():installed(false),enqueued(false),orientation(Matrix<>::eye3),actor(NULL),sector_translation(0)
											{}
	virtual									~UniqueStaticStructure()
											{
												if (env.scene && actor && !application_shutting_down)
													env.scene->releaseActor(*actor);
												if (enqueued)
													removeFromQueue();
											}
			
			void							updateFromGeometry(const CGS::Geometry<>&);
			void							updateFromHull(const Mesh<CGS::SubGeometryA<>::PhDef>&hull);
			void							updatePose();
			void							install();	//!< Installs this geometry to PhysX scenery as described by StructurePrototype::env
			void							uninstall();	//!< Removes this geometry from the scenery (if installed)
			bool							isInstalled()	const //! Checks if this track segment is currently installed
											{
												return installed;
											}
			void							adoptData(UniqueStaticStructure&other);

			void							applyPose();


	};
	
	/**
		@brief Physical track segment
		
		The track segment directly inherits from StructurePrototype rather than Structure because due to the bending process, these structures are all unique anyway (unfortunately).
	*/
	class TrackSegment:public UniqueStaticStructure,public CGS::TrackSegment
	{
	private:
			//Auto<bool>						installed;	//!< True if this segment has been installed (applied to the PhysX scenery
	public:
	
			CGS::Geometry<>					bent_geometry;
											//scale_texture;
			//Auto<NxActor*>					actor;		//!< Pointer to the instantiated PhysX actor
			
			
			/**
				@brief Updates the underlying geometry based on the current configuration.
				
				This method must be called whenever any of the CGS::TrackSegment end points or the linked tile change. The tile geometry is bent along the specified spline.
				The resulting geometry is scaled automatically according to env.system_unit_size.
				To prevent scaling, set the local environment construct's (StructurePrototype::env) system unit size to 1.
				Automatically generates a new actor if necessary.
			*/
			void							update();
			
			
			/*void							install();	//!< Installs this geometry to PhysX scenery as described by StructurePrototype::env
			void							uninstall();	//!< Removes this geometry from the scenery (if installed)
			bool							isInstalled()	const //! Checks if this track segment is currently installed
											{
												return installed;
											}*/
			
	virtual	void							onDisconnectFrom(CGS::TrackConnector*)	//! Callback event invoked by CGS::TrackSegment operations
											{
												uninstall();
											}
	virtual	void							onConnectTo(CGS::TrackConnector*)	//! Callback event invoked by CGS::TrackSegment operations
											{}
	};
	
	
	
	/**
		@brief Collection of track nodes that either form a strip or a loop
		
		The track is by itself not usable as a physical entity. In order to use it, a collection of segments must first be generated using the Track::exportTo() method.
	*/
	class Track
	{
	public:
			struct TNode	//! Track node definition
			{
				Composite::Coordinates		coordinates;		//!< Absolute node position
				float3						up;						//!< Normalized up axis of this node
				float						width_scale,		//!< Width scale to apply to track meshes at this node
											height_scale;		//!< Height scale to apply to track meshes at this node
				float3						direction;			//!< Normalized direction vector
				float2						scale_direction;	//!< Scale inclination. May be of any length. Typically {0,0}
			};
			
			Auto<bool>						closed;	//!< Indicates that the last node should again be connected to the first one
			Buffer<TNode>					nodes;	//!< Collection of nodes that form the strip or loop as described by this track
			
			
			/**
				@brief Exports the local track configuration to a sequence of track segments for rendering and physical interaction
				
				@param segments [out] The array to write the segments to. Will be resized automatically to match the necessary number of segments
				@param sector_size Sector size to apply during coordinate transformation
				@param adjust_up_vectors If true then the up axis of each node will be adjusted so that it is normal to the respective direction vector
			*/
			void							exportTo(Array<TrackSegment>&segments, float sector_size, bool adjust_up_vectors=true);
	};
	
	
	/**
		@brief Vehicle instance as generated from a vehicle prototype
	*/
	class Vehicle:public Entity
	{
	public:
			//configuration:
			CGS::AnimatableInstance<>		instance;			//!< CGS structure instance that allows animation of wheel components
			VehiclePrototype				*prototype;			//!< Link to the parent prototype (not NULL)
			Array<Engine>					engines;			//!< Array of engine instances as required by the vehicle prototype (excluding wheel drive)
			const PhFloat					radius,				//!< Vehicle radius (from the point of origin)
											mass;				//!< Vehicle mass as retrieved from the vehicle configuration
			NxScene							*scene;				//!< Simulating PhysX scene (not NULL)

			TMatrix4<double>				accurate_matrix;		//!< Accurate orientation+position retrieved from PhysX
			
			int								current_gear;			//!< Gear that the vehicle is currently running. May be negative to indicate reverse gear(s)
			float							current_motor_speed;	//!< Speed that the motor is currently running at
			bool							controls_locked,		//!< Indicates the owning user cannot alter this vehicle's state. Conversely the user may stop updating until this setting is removed
											parked,					//!< Indicates the car should remain with brakes at 100% until the user hits the acceleration control
											has_outer_force;		//!< Indicates the the vehicle is subject to an outer force. Defaults to false
			
			OpenAL::Source					wheel_engine_sound_source0;	//!< Sound player for engine sound (0)
			OpenAL::Source					wheel_engine_sound_source1;	//!< Sound player for engine sound (1)
			
			//status:
			/*Vec3<float>					momentum,					//!< Rotation momentum
											last_frame_movement;		//!< Product of inertia and tdelta*/
			float							acceleration,				//!< Acceleration efficiency (wheels only)
											signature[EmissionTypes],	//!< Drive emission
											fuel_consumption,			//!< Current vehicle fuel consumption
											energy_consumption,			//!< Current vehicle energy consumption (non-fuel)
											wing_grip,					//!< Grip that the wings have currently on the surrounding environment
											control_grip;				//!< Grip that the player has on the orientation of the ship
			float3							center_of_gravity,			//!< Vehicle center of gravity (in vehicle space)
											outer_force;				//!< Active outer force vector. Effective only if has_outer_force is true
			Array<Wheel>					wheels;						//!< Collection of all intantiated wheels
			Engine							wheel_engine;				//!< Engine instance that drives the wheels
			CGS::AnimatorInstanceA<>		*steer_left,				//!< Animator link for left steering animation. Must be named 'steer_left' in the CGS structure. May be NULL
											*steer_right,				//!< Animator link for right steering animation. Must be named 'steer_right' in the CGS structure. May be NULL
											*accel,						//!< Animator link for the acceleration animation. Must be named 'accel' in the CGS structure. May be NULL
											*brake;						//!< Animator link for the brake animation. Must be named 'brake' in the CGS structure. May be NULL
			NxActor							*actor;						//!< Pointer to the PhysX actor instance (not NULL)

			float							engine_sound_volume;		//!< Engine volume factor to apply to the engine noise of this vehicle. Must be in the range [0,1] where 0 is muted

			struct	State
			{
				float3						position;
				TMatrix3<>					orientation;
				float3						linear_velocity,
											angular_velocity;
				Timer::Time					captured;
				bool						override;		//!< Force PhysX to adapt to the above specified state when next appropriate
			}								state;

			
			//controls:
			float							throttle;					//!< Throttle control [-1,+1].  0 by default, reset to 0 after simulation has finished
			
											Vehicle(const TEnvironment&env, VehiclePrototype&prototype);
											~Vehicle();
			void							process(const TEnvironment&env, float delta);	//!< Processes this vehicle. Called by simulate() automatically
			//void							applyForce(const Composite::Coordinates&position, const PhFloat vector[3], const PhFloat&factor);
			void							reset();										//!< Indicates that this vehicle should be reset to the point of origin. Local data is reset immediately. Simulation aspects are reset during the next simulation phase
			void							featherAccurateMatrix(float delta);

			void							createActor();	//!< Automatically called by simulate()
	};
	
	
	
	
	extern Buffer<float4>						explosions;
	extern LogFile								logfile;				//!< Log file to write events to
	extern HashTable<EngineType*>				engine_type_map;		//!< Hashtable to find engine types by name (filled by init())
	extern List::Vector<EngineType>				engine_types;			//!< Linear list of all supported engine types (filled by init())
	extern List::ReferenceVector<Structure>		dynamic_structures,		//!< Linear list of all currently simulated dynamic structures (excluding vehicles)
												static_structures;		//!< Linear list of all currently simulated static (inanimate) structures (excluding track segments)
	extern List::ReferenceVector<Vehicle>		simulated_vehicles;		//!< Linear list of all currently simulated vehicles
	extern List::ReferenceVector<FirstPerson>	simulated_fps;			//!< Linear list of all currently simulated first person entities
	extern Buffer<UniqueStaticStructure*>		installed_unique_static_structures;		//!< Linear list of all currently simulated simple structures
	//extern MappedScenery<OpenGL>			scenery;
	extern HashTable<VehiclePrototype*>	prototypes;				//!< Hashtable to find vehicle prototypes by filename. Maintained by loadPrototype()
	extern List::Vector<StructurePrototype>		structure_prototypes;		//!< Linear list of structure prototypes. Maintained by loadStructurePrototype()
	extern HashTable<StructurePrototype*>		structure_prototype_map;	//!< Hashtable to find structure prototypes by filename. Maintained by loadStructurePrototype()
	extern Vehicle								*player_attached_to;		//!< Simulated vehicle that the player is currently attached to

	NxScene*									init(bool generate_debug_info);						//!< Initializes physical simulation and returns a pointer to the active PhysX scenery or NULL if initialization failed. The function also initializes the available engine prototypes

	const NxDebugRenderable*					getDebugRenderable();

	extern	void								(*onVehicleErase)(Vehicle*);
	
	void										signalExplosion(const TVec3<>&position, float force);			//!< Sends a point explosion to physics, blasting everything around it

	VehiclePrototype*							loadPrototype(const TEnvironment&env,const String&filename);								//!< Loads a vehicle prototype from the specified file using the specified environment definition. If the operation succeeds, then the returned object will automatically be mapped to the local hashtable and linear list. Subsequent loading of the same filename will return the same structure. Do not delete the returned object. @return Pointer to the loaded prototype or NULL if loading failed
	StructurePrototype*							createStructurePrototype(const TEnvironment&env, CGS::Geometry<>&geometry, bool dynamic);	//!< Creates a new structure prototype using the specified generated or pre-loaded geometry. The returned prototype is @b not automatically mapped and must be deleted by the client application if no longer required. @param env Environment definition to use during loading @param geometry Geometry to use for the prototype @param dynamic Set true if this prototype should describe a dyamic structure
	StructurePrototype*							loadStructurePrototype(const TEnvironment&env, const String&filename, bool dynamic);		//!< Loads a structure prototype from the specified file using the specified environment definition. If the operation succeeds, then the returned object will automatically be mapped to the local hashtable and linear list. Subsequent loading of the same filename will return the same structure. Do not delete the returned object. @param dynamic Set true if this prototype should describe a dyamic structure @return Pointer to the loaded prototype or NULL if loading failed
	
	/**
		@brief Generates a new structure instance from an existing prototype
		
		Use the discard() function to delete the returned object. Do @b not manually delete the object via @a delete
		
		@param env Environment definition to use for the creation process
		@param prototype Structure prototype to use. The function returns NULL if NULL is passed as prototype
		@return Pointer to a new structure or NULL if no prototype was specified
	*/
	Structure*								createFromPrototype(const TEnvironment&env, StructurePrototype*prototype);
	/**
		@brief Generates a new vehicle instance from an existing prototype
		
		Use the discard() function to delete the returned object. Do @b not manually delete the object via @a delete
		
		@param env Environment definition to use for the creation process
		@param prototype Structure prototype to use. The function returns NULL if NULL is passed as prototype
		@return Pointer to a new vehicle or NULL if no prototype was specified
	*/
	Vehicle*								createFromPrototype(const TEnvironment&env, VehiclePrototype*prototype);
	/**
		@brief Generates both vehicle prototype and a new instance from the specified file
		
		The function internally calls loadPrototype() preventing the same file from being loaded multiple times.
		Use the discard() function to delete the returned object. Do @b not manually delete the object via @a delete
		
		@param env Environment definition to use for the loading/creation process
		@param filename CGS Filename to load from
		@return Pointer to a new vehicle or NULL if prototype loading failed
	*/
	Vehicle*								createFromFile(const TEnvironment&env,const String&filename);
	
	FirstPerson*							createFPS(float height);	//!< Generates a new first person instance using the specified instance height in meters
	/**
		@brief Generates a new structure prototype and instance from a simple CGS geometry prototype
		
		This function should not be overly used as it generates a new structure prototype with each invokation.
		Use the discard() function to delete the returned object. Do @b not manually delete the object via @a delete
		
		@param env Environment definition to use for the creation process
		@param prototype CGS geometry to use as prototype
		@param dynamic Set true if this object should be dynamic, false otherwise
	*/
	Structure*								createStructure(const TEnvironment&env, CGS::Geometry<>&prototype, bool dynamic=false);
	
	void									discard(Vehicle*vehicle);					//!< Discards the specified instance. Uninstallation and removal from any governing lists are done automatically
	void									discard(FirstPerson*vehicle);				//!< @overload
	void									discard(Structure*structure);				//!< @overload
	void									discard(StructurePrototype*prototype);		//!< @overload
	
	
	/**
		@brief Advances the simulation by the specified amount of seconds
		
		simulate() updates all simulated entities and forwards the current state to PhysX.
		
		@param env Environment configuration to use
		@param delta Time frame (in seconds) that should be simulated
		@return Time (in seconds) that were actually simulated. This is the product of the current frame length and the number of processed frames
	*/
	float									simulate(const TEnvironment&env,float delta);
	
	/**
		@brief Updates sector relative coordinates in relation to the specified observer sector coordinates
		
		This function must be called each frame unless the observer (currently or always) resides in sector coordinates {0,0,0}.
		
		
		@param env Environment configuration to use
		@param observer_sector Current observer sector coordinates
	*/
	void									relativate(const TEnvironment&env, const TVec3<Composite::sector_t>&observer_sector);
	


	class ErrorPrint : public NxUserOutputStream
	{
	public:
	virtual void reportError(NxErrorCode code, const char * message, const char *file, int line)
	{
		cout << "NxError("<<code<<"): '"<<message<<"'"<<nl;
		logfile << "NxError("<<code<<"): '"<<message<<"'"<<nl;
	}
	/**
	\brief Reports an assertion violation.  The user should return 

	\param message Message to display.
	\param file File error occured in.
	\param line Line number error occured on.
	*/
	virtual NxAssertResponse reportAssertViolation(const char * message, const char *file, int line)
	{
		cout << "NxAssertionViolation: '"<<message<<"'"<<nl;
		logfile << "NxAssertionViolation: '"<<message<<"'"<<nl;
		return NX_AR_BREAKPOINT;
	}
	/**
	\brief Simply prints some debug text

	\param message Message to display.
	*/
	virtual void print(const char * message)
	{
		ErrMessage(message);
	}


	};


}



#endif
