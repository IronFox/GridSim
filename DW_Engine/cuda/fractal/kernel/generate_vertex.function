/*
	Vertex data processor
	
	generateVertex(T[Device/Host]Surface surface, T[Device/Host]Surface parent, TContext context,const TVertexInfo*info_field, unsigned vertex_count)
	
	surface: Surface segment to generate a vertex of
	parent: Parent surface segment
	context: Fractal body configuration
	info_field: Vertex information array

*/

	#if defined(__DEVICE_CALL__) && defined(__USE_SHARED_MEMORY__)
		__shared__	TVertex			parent_field[vertex_count];
		__shared__	TVertexInfo		info_field[vertex_count];
		__shared__	bool			parent_entry_defined[vertex_count];
		... need more info
		
		
	
	#else
		DEVICE_RESOURCE(TVertexInfo,info) = info_field[linear];
	#endif
	
	
	TVertex&result = surface.vertex[linear];
	
	float delta[3];
	cSub(parent.sector,surface.sector,delta,context.sector_size);
	
	if (info.grid_vertex)
	{
		result = parent.vertex[info.parent_space[surface.child_index].match];
		dvAdd(result.position,delta);
		//result.channel.age = 1.0f + (result.channel.age-1.0f)*0.5f;
		//dvClear(result.normal);
		//setHeight(result.position,surface.uniform_height,surface,context.sector_size);
		//result.height = height(result.channel);
		//setHeight(result.position,h,result.height,surface,context);
		

		
				//works but needs tweaking:
		//option one: fixed. good for near planar areas, near functionless for inclined regions:
		
		float h,min=1,max=-1,rng=0,avg=0;
		const unsigned int	x = info_field[info.parent_space[surface.child_index].match].x,
							y = info_field[info.parent_space[surface.child_index].match].y;
		
		unsigned y_max = context.edge_length-1;
		/*if (x > 0 && x < y && y < y_max)
		{
			float	med0 = (parent.vertex[vertexIndex(x-1,y)].height+parent.vertex[vertexIndex(x+1,y)].height)/2.0f,
					med1 = (parent.vertex[vertexIndex(x,y-1)].height+parent.vertex[vertexIndex(x,y+1)].height)/2.0f,
					med2 = (parent.vertex[vertexIndex(x-1,y-1)].height+parent.vertex[vertexIndex(x+1,y+1)].height)/2.0f;
			
			min = fminf(fminf(med0,med1),med2);
			max = fmaxf(fmaxf(med0,med1),med2);
			avg = (med0+med1+med2)/3.0f;
			rng = fmaxf(fmaxf(fabsf(med0-avg),fabsf(med1-avg)),fabsf(med2-avg))*6.0f;
		}
		else*/
		{
			if (x)
			{
				h = parent.vertex[vertexIndex(x-1,y)].FRACTAL_HEIGHT;
				
				if (h < min)
					min = h;
				if (h > max)
					max = h;
				
				if (y)
				{
					h = parent.vertex[vertexIndex(x-1,y-1)].FRACTAL_HEIGHT;
					if (h < min)
						min = h;
					if (h > max)
						max = h;
				}
			}
			if (x < y)
			{
				h = parent.vertex[vertexIndex(x+1,y)].FRACTAL_HEIGHT;
				if (h < min)
					min = h;
				if (h > max)
					max = h;
				
				if (y)
				{
					h = parent.vertex[vertexIndex(x,y-1)].FRACTAL_HEIGHT;
					if (h < min)
						min = h;
					if (h > max)
						max = h;
				}
			}
			if (y < y_max)
			{
				h = parent.vertex[vertexIndex(x,y+1)].FRACTAL_HEIGHT;
				if (h < min)
					min = h;
				if (h > max)
					max = h;
				
				h = parent.vertex[vertexIndex(x+1,y+1)].FRACTAL_HEIGHT;
				if (h < min)
					min = h;
				if (h > max)
					max = h;
			}
			avg = (min+max)/2.0f;
			rng = fmaxf((max-min)/2.0f,0.001f);//0.75f;
		}
		
		
		float depth = (float)surface.depth/context.recursive_depth;
		result.channel.age = getWeight(result.FRACTAL_HEIGHT,avg,rng,depth);
		return;
	}
	DEVICE_RESOURCE(TVertex,p0) = parent.vertex[info.parent_space[surface.child_index].parent0];
	DEVICE_RESOURCE(TVertex,p1) = parent.vertex[info.parent_space[surface.child_index].parent1];
	DEVICE_RESOURCE(TVertex,p2) = parent.vertex[info.parent_space[surface.child_index].parent2];

	
	/*for (unsigned i = 0; i < linear; i++)
		getRandom(seed);*/
	
	if (info.edge_index != -1)
	{
		
		unsigned elinear;
		switch (info.edge_index)
		{
			case 0:
				elinear = info.y;
			break;
			case 1:
				elinear = info.x;
			break;
			case 2:
				elinear = context.edge_length-info.x-1;
			break;
		}
		if (p0.position[0] > p1.position[0])
			elinear = context.edge_length-elinear-1;
				
		int seed = surface.outer_seed[info.edge_index]+(((elinear*15+3)*(elinear*11+2)));
		generate3(p0,p1,p2,result,seed,surface,context);
	}
	else
	{
		int seed = surface.inner_seed+(((linear*15+3)*(linear*11+2)));
		generate4(p0,p1,p2,parent.vertex[info.parent_space[surface.child_index].parent3],result,seed,surface,context);
	}
		//generate4(p0,p1,p2,parent.vertex[info.parent_space[surface.child_index].parent3],result,surface.inner_seed+(((linear*15+3)*(linear*11+2))&0xFFFF),surface,context);
		//generate4(p0,p1,p2,parent.vertex[info.parent_space[surface.child_index].parent3],result,surface.inner_seed+((int*)p0.position)[0]+((int*)p0.position)[1]*3+((int*)p0.position)[2]*7,surface,context);

	//result.height = height(result.channel);
	dvCenter(p0.position,p1.position,result.position);
	dvAdd(result.position,delta);
	
	#ifdef RIVERS
		result.height = result.fractal_height - riverIntensity(info.x,info.y,surface.river_nodes,surface.river_lengths,num_rivers);
	#endif
	
	setHeight(result.position,(p0.height+p1.height)/2,result.height,surface,context);
