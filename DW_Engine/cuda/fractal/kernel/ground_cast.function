	DEVICE_RESOURCE(TVertex,v0) = surface.vertex[triangle_indices[linear*3]];
	DEVICE_RESOURCE(TVertex,v1) = surface.vertex[triangle_indices[linear*3+1]];
	DEVICE_RESOURCE(TVertex,v2) = surface.vertex[triangle_indices[linear*3+2]];

	float	d0[3],d1[3],n[3],dif[3],n0[3],n1[3],cross_point[3];
	if (dvDot(v0.normal,d)>0.0f)
		return;

	dvSub(v1.position,v0.position,d0);
	dvSub(v2.position,v0.position,d1);
	dvCross(d0,d1,n);
	dvSub(v0.position,b,dif);
	float	sub_alpha = dvDot(n,d);
	if (sub_alpha==0.0f)
		return;
	float	alpha = dvDot(n,dif)/sub_alpha;
	dvCross(n,d0,n0);
	dvCross(n,d1,n1);
	dvMad(b,d,alpha,cross_point);
	dvSub(cross_point,v0.position,dif);
	float	beta = dvDot(n0,dif)/dvDot(n0,d1),
			gamma = dvDot(n1,dif)/dvDot(n1,d0);
	if (beta >= 0 && gamma >= 0 && beta+gamma <= 1)
	{
		if (_atomicCAS(&ground->isset, 0, 1))
		{
			ground->height_above_ground = alpha;
			ground->ground_height = v0.height + (v1.height-v0.height)*gamma + (v2.height-v0.height)*beta;
			dvMad(v0.position,d0,gamma,ground->position);
			dvMad(ground->position,d1,beta);
			float	nd0[3],
					nd1[3];
			dvSub(v1.normal,v0.normal,nd0);
			dvSub(v2.normal,v0.normal,nd1);
			dvMad(v0.normal,nd0,gamma,ground->normal);
			dvMad(ground->normal,nd1,beta);
		}
	}