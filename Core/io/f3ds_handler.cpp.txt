#include <global_root.h>
#include "f3ds_handler.h"

/******************************************************************************************

Depreciated 3ds-chunk-reader.

This file is part of the DeltaWorks-Foundation or an immediate derivative core application.
Original Author: Stefan Elsen
Copyright (C) 2006 University of Trier, Computer Science Department, Germany.

A royalty-free, non-exclusive, perpetual right to read, modify, compile,
and/or use this file in any way suited is hereby granted to all students and associates
of the Computer Science Department of the University of Trier.
This right may be granted to other individuals or parties in any modified form as well
as denied to any member of the above mentioned group by the Auhorities of the
Computer Science Department of the University of Trier.

The right granted in the above section is expressly made subject to and limited by the
following conditions and restrictions:
a) Any modifications to this file must be made available to the Computer Science Department
of the University of Trier.
b) Disclosure of this file, modified or unmodified, in parts or in its entirety to third
parties is strictly prohibited.

All rights and privileges that have not explicitly been granted are reserved.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

******************************************************************************************/


char F3DS_HEX_CHAR_BUFFER[5]="    ";

WORD MapID[]  = {0xA200,0xA33A,0xA210,0xA230,0xA33C,0xA204,0xA33D,0xA220,0xA33E,0xA340,0xA342,0xA344,0xA346,0xA348,0xA34A,0xA34C};
void makeClear(S_3dsMap&map)
{
    map.file_name[0] = 0;
    map.scale[0] = 1;
    map.scale[1] = 1;
    map.offset[0] = 0;
    map.offset[1] = 0;
    map.rotation = 0;
    map.set = false;
}


char hexChar(unsigned char val)
{
return val < 10?'0'+val:'A'+(val-10);
}

void C_3dsFile::mark()
{
    marked = chunk;
}

void C_3dsFile::recall()
{
    chunk = marked;
    reLocate();
}

void C_3dsFile::reLocate()
{
    fseek(f,chunk.addr+6,SEEK_SET);
}


bool C_3dsFile::enterWrite()
{
    fclose(f);
    f = fopen(file_name,"wb");
    if (!f)
    {
        f = fopen(file_name,"rb");
        return false;
    }
    return true;
}

void C_3dsFile::exitWrite()
{
    fclose(f);
    f = fopen(file_name,"rb");
}


C_3dsFile::C_3dsFile():f(NULL),reg_combo_cnt(0),hcnt(0),file_name(NULL),streaming(false)
{}

C_3dsFile::~C_3dsFile()
{
    close();
    deloc(file_name);
}

bool C_3dsFile::open(const char*filename)
{
    close();
    unsigned len = strlen(filename);
    if (!len) return false;
    file_name = SHIELDED_ARRAY(new char[len+1],len+1);
    strcpy(file_name,filename);
    f = fopen(file_name,"rb");
    if (!f)
        return false;
    reset();
    return true;
}

bool C_3dsFile::reOpen()
{
    close();
    if (!file_name) return false;
    f = fopen(file_name,"rb");
    if (!f)
        return false;
    reset();
    return true;
}


bool C_3dsFile::create(const char*filename)
{
    close();
    f = fopen(file_name,"wb");
    if (!f)
        return false;
    fclose(f);
    f = fopen(file_name,"rb");
    if (!f)
        return false;
    reset();
    return true;
}

void C_3dsFile::close()
{
    streaming = false;
    if (!f) return;
    fclose(f);
    f = NULL;
}

void C_3dsFile::reset()
{
    streaming = false;
    if (!f) return;
    hcnt = 0;
    fseek(f,0,SEEK_END);
    file_size = ftell(f);
    fseek(f,0,SEEK_SET);
    first();
}

bool C_3dsFile::first()
{
    if (streaming) return false;
    if (!hcnt)
    {
        chunk.addr = 0;
        if (file_size < 6)
            return false;
    }
    else
    {
        chunk.addr = history[hcnt-1].addr+6+history[hcnt-1].head_size;
        if (history[hcnt-1].size < 6)
            return false;
    }
    fseek(f,chunk.addr,SEEK_SET);
    fread(&chunk.id,sizeof(chunk.id),1,f);
    fread(&chunk.size,sizeof(chunk.size),1,f);
    chunk.index = 0;
    return true;
}

bool C_3dsFile::next()
{
    if (streaming) return false;
    unsigned size,start;
    if (!hcnt)
    {
        size = file_size;
        start = 0;
    }
    else
    {
        size = history[hcnt-1].size;
        start = history[hcnt-1].addr;
    }
    if ((chunk.addr+chunk.size)-start >= size)
        return false;
    chunk.addr+=chunk.size;
    fseek(f,chunk.size-6,SEEK_CUR);
    fread(&chunk.id,sizeof(chunk.id),1,f);
    fread(&chunk.size,sizeof(chunk.size),1,f);
    chunk.index++;
    return true;
}

void C_3dsFile::reg(WORD id, short head_data_size)
{
    reg_combo[reg_combo_cnt++] = MAKELONG(id,head_data_size);
}

void C_3dsFile::reg(WORD id)
{
    reg_combo[reg_combo_cnt++] = MAKELONG(id,0);
}



void C_3dsFile::defArray(short arrayid, WORD count, WORD el_size)
{
    ar_def_cnt[arrayid-ARRAY0] = count;
    ar_def_size[arrayid-ARRAY0] = el_size;
}

bool C_3dsFile::findFirst(WORD id)
{
    if (streaming) return false;
    mark();
    if (first())
        do
            if (chunk.id == id) return true;
        while (next());
    recall();
    return false;
}

bool C_3dsFile::findNext(WORD id)
{
    if (streaming) return false;
    mark();
    while (next())
        if (chunk.id == id) return true;
    recall();
    return false;
}

bool C_3dsFile::select(unsigned index)
{
    if (streaming) return false;
    while (index > chunk.index && next());
    if (index == chunk.index)
        return true;
    first();
    while (index > chunk.index && next());
    return index == chunk.index;
}


void C_3dsFile::forceEnter()
{
    if (streaming) return;
    history[hcnt++] = chunk;
    history[hcnt-1].head_size = 0;
    chunk.addr = ftell(f);
    fread(&chunk.id,sizeof(chunk.id),1,f);
    fread(&chunk.size,sizeof(chunk.size),1,f);
    chunk.index = 0;
}


bool C_3dsFile::enter()
{
    if (streaming) return false;
    for (unsigned i = 0; i < reg_combo_cnt; i++)
        if (LOWORD(reg_combo[i]) == chunk.id)
        {
            history[hcnt++] = chunk;
            short size = HIWORD(reg_combo[i]);
            history[hcnt-1].head_size = size;
            if (size < 0)
                switch (size)
                {
                    case STRZ:
                    {
                        char b;
                        unsigned cnt = 0;
                        do
                        {
                            fread(&b,1,1,f);
                            cnt++;
                        }
                        while (b);
                        history[hcnt-1].head_size = cnt;
                    }
                    break;
                    case ARRAY0:
                    case ARRAY1:
                    case ARRAY2:
                    case ARRAY3:
                    case ARRAY4:
                    case ARRAY5:
                    case ARRAY6:
                    case ARRAY7:
                    {
                        unsigned cnt = 0,id = -(size-ARRAY0);
                        fread(&cnt,ar_def_cnt[id],1,f);
                        fseek(f,cnt*ar_def_size[id],SEEK_CUR);
                        history[hcnt-1].head_size = ar_def_cnt[id]+cnt*ar_def_size[id];
                    }
                    break;
                }
                else
                    fseek(f,size,SEEK_CUR);
            chunk.addr = ftell(f);
            fread(&chunk.id,sizeof(chunk.id),1,f);
            fread(&chunk.size,sizeof(chunk.size),1,f);
            chunk.index = 0;
            return true;
        }
    return false;
}

bool C_3dsFile::dropBack()
{
    if (streaming) return false;
    if (!hcnt) return false;
    hcnt--;
    chunk = history[hcnt];
    reLocate();
    return true;
}

unsigned C_3dsFile::getSize()
{
    return chunk.size-6;
}

short C_3dsFile::getHeadSize()
{
    return chunk.head_size;
}

WORD C_3dsFile::getID()
{
    return chunk.id;
}

unsigned C_3dsFile::getIndex()
{
    return chunk.index;
}

unsigned C_3dsFile::get(void*out)
{
    if (streaming) return 0;
    mark();
    fread(out,chunk.size-6,1,f);
    recall();
    return chunk.size-6;
}

const char*C_3dsFile::getHexIDString()
{
WORD id = chunk.id;
unsigned char b1 = HIBYTE(id),
              b2 = LOBYTE(id);
F3DS_HEX_CHAR_BUFFER[0] = hexChar(b1>>4);
F3DS_HEX_CHAR_BUFFER[1] = hexChar(b1&0xF);
F3DS_HEX_CHAR_BUFFER[2] = hexChar(b2>>4);
F3DS_HEX_CHAR_BUFFER[3] = hexChar(b2&0xF);
return F3DS_HEX_CHAR_BUFFER;
}

void C_3dsFile::openStream()
{
    if (!f || streaming) return;
    mark();
    streaming = true;
}

void C_3dsFile::stream(int size, void*pntr,unsigned max_size)
{
    if (size >= 0)
    {
        if ((unsigned)size > max_size)
            size = max_size;
        fread(pntr,size,1,f);
        return;
    }
    switch(size)
    {
        case STRZ:
        {
            char*b=reinterpret_cast<char*>(pntr);
            unsigned s = 0;
            do
                fread(&b[s],1,1,f);
            while (b[s++] && s < max_size);
            if (s == max_size)
                b[max_size-1] = 0;
        }
        break;
        case ARRAY0:
        case ARRAY1:
        case ARRAY2:
        case ARRAY3:
        case ARRAY4:
        case ARRAY5:
        case ARRAY6:
        case ARRAY7:
            MessageBox(NULL,"can't read array in stream!","streaming-error",MB_OK);
        break;
    }
}

void C_3dsFile::closeStream()
{
    if (!f || !streaming) return;
    recall();
    streaming = false;
}

bool C_3dsFile::insertData(WORD id, void*head_data)
{
    //tbc...
    return false;
}

bool C_3dsFile::insertData(WORD id, void*data, unsigned size)
{
    //tbc...
    return false;
}


unsigned C_3dsFile::countMaterials()
{
reset();
forceEnter();
    findFirst(0x3D3D);
    forceEnter();
        unsigned cnt = 0;
        if (findFirst(0xAFFF))
            do
                cnt++;
            while (findNext(0xAFFF));
        return cnt;
}


unsigned C_3dsFile::getMaterials(S_3dsMaterial*out)
{
reset();
forceEnter();
    findFirst(0x3D3D);
    forceEnter();
        unsigned cnt = 0;
        if (findFirst(0xAFFF))
            do
            {
                forceEnter();
                    if (findFirst(0xA000))
                        get(out[cnt].name);
                    else
                        MessageBox(NULL,"name not found","material_error",MB_OK);
                    if (findFirst(0xA010))
                    {
                        forceEnter();
                            smartConvertChunk(out[cnt].ambient);
                        dropBack();
                    }
                    else
                        MessageBox(NULL,"ambient color not found","material_error",MB_OK);
                    if (findFirst(0xA020))
                    {
                        forceEnter();
                            smartConvertChunk(out[cnt].diffuse);
                        dropBack();
                    }
                    else
                        MessageBox(NULL,"diffuse color not found","material_error",MB_OK);
                    if (findFirst(0xA030))
                    {
                        forceEnter();
                            smartConvertChunk(out[cnt].specular);
                        dropBack();
                    }
                    else
                        MessageBox(NULL,"specular color not found","material_error",MB_OK);
                    if (findFirst(0xA040))
                    {
                        forceEnter();
                            smartConvertChunk(&out[cnt].shininess);
                        dropBack();
                    }
                    else
                        MessageBox(NULL,"shininess not found","material_error",MB_OK);
                    if (findFirst(0xA041))
                    {
                        forceEnter();
                            smartConvertChunk(&out[cnt].shininess_strength);
                        dropBack();
                    }
                    else
                        MessageBox(NULL,"shininess_strength not found","material_error",MB_OK);

                    float dummy;
                    for (unsigned i = 0; i < 16; i++)
                    {
                        makeClear(out[cnt].map[i]);
                        if (findFirst(MapID[i]))
                        {
                            forceEnter();
                                out[cnt].map[i].set = true;
                                if (findFirst(0xA300))
                                    get(out[cnt].map[i].file_name);
                                if (findFirst(0xA354))
                                {
                                    get(&dummy);
                                    out[cnt].map[i].scale[1] = dummy;
                                }
                                if (findFirst(0xA356))
                                {
                                    get(&dummy);
                                    out[cnt].map[i].scale[0] = dummy;
                                }
                                if (findFirst(0xA358))
                                {
                                    get(&dummy);
                                    out[cnt].map[i].offset[0] = dummy;
                                }
                                if (findFirst(0xA35A))
                                {
                                    get(&dummy);
                                    out[cnt].map[i].offset[1] = dummy;
                                }
                                if (findFirst(0xA35C))
                                {
                                    get(&dummy);
                                    out[cnt].map[i].rotation = dummy;
                                }
                            dropBack();
                        }
                    }
                dropBack();
                out[cnt++].link = NULL;
            }
            while (findNext(0xAFFF));
        return cnt;
}


void C_3dsFile::smartConvertChunk(float*out)
{
unsigned char buffer[36];
switch (chunk.id)
{
    case 0x0010:
         get(out);
    break;
    case 0x0011:
    {
        get(buffer);
        out[0] = (float)buffer[3]/255.0;
        out[1] = (float)buffer[4]/255.0;
        out[2] = (float)buffer[5]/255.0;
    }
    break;
    case 0x0012:
    {
        get(buffer);
        out[0] = (float)buffer[0]/255.0;
        out[1] = (float)buffer[1]/255.0;  //ignore gamma-correction
        out[2] = (float)buffer[2]/255.0;
    }
    break;
    case 0x0013:
    {
        float*b = (float*)buffer;
        get(buffer);
        out[0] = b[0];
        out[1] = b[1];  //ignore gamma-correction
        out[2] = b[2];
    }
    break;
    case 0x0030:
    {
        WORD*b = (WORD*)buffer;
        get(b);
        out[0] = b[0];
    }
    break;
    case 0x0031:
    {
        float*b = (float*)buffer;
        get(b);
        out[0] = b[0];
    }
    break;
}
}



//--------------------------------------------------------------------------
